<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MAXIS STRIKE</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Russo+One&family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');
  * { margin:0; padding:0; box-sizing:border-box; }
  body { background:#000; overflow:hidden; font-family:'Share Tech Mono',monospace; color:#fff; cursor:default; }
  canvas { display:block; }

  /* MENU */
  #menu {
    position:fixed; inset:0; z-index:100;
    background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #0a0a0a 100%);
    display:flex; flex-direction:column; align-items:center; justify-content:center;
  }
  #menu.hidden { display:none; }

  .menu-bg-effect {
    position:absolute; inset:0; overflow:hidden; pointer-events:none;
  }
  .menu-bg-effect::before {
    content:''; position:absolute; width:200%; height:200%; top:-50%; left:-50%;
    background: radial-gradient(circle at 30% 40%, rgba(255,100,0,0.05) 0%, transparent 50%),
                radial-gradient(circle at 70% 60%, rgba(0,150,255,0.05) 0%, transparent 50%);
    animation: bgRotate 20s linear infinite;
  }
  @keyframes bgRotate { to { transform:rotate(360deg); } }

  .menu-lines {
    position:absolute; inset:0; pointer-events:none; opacity:0.03;
    background: repeating-linear-gradient(0deg, transparent, transparent 2px, #fff 2px, #fff 3px);
  }

  .logo-container { text-align:center; margin-bottom:40px; position:relative; z-index:2; }
  .logo-sub { font-family:'Share Tech Mono',monospace; font-size:14px; color:#ff6600; letter-spacing:8px; text-transform:uppercase; margin-bottom:8px; }
  .logo-main {
    font-family:'Orbitron',sans-serif; font-size:72px; font-weight:900;
    background: linear-gradient(180deg, #fff 0%, #ff6600 50%, #cc3300 100%);
    -webkit-background-clip:text; -webkit-text-fill-color:transparent;
    text-shadow: none; filter: drop-shadow(0 0 30px rgba(255,100,0,0.3));
    letter-spacing:6px;
  }
  .logo-edition { font-family:'Share Tech Mono'; font-size:11px; color:#666; letter-spacing:12px; margin-top:5px; }

  .menu-buttons { display:flex; flex-direction:column; gap:4px; position:relative; z-index:2; min-width:320px; }
  .menu-btn {
    background: linear-gradient(90deg, rgba(255,102,0,0) 0%, rgba(255,102,0,0.08) 50%, rgba(255,102,0,0) 100%);
    border:none; color:#ccc; font-family:'Share Tech Mono',monospace; font-size:15px;
    padding:14px 40px; cursor:pointer; text-transform:uppercase; letter-spacing:4px;
    transition: all 0.2s; position:relative; text-align:left;
    border-left:2px solid transparent;
  }
  .menu-btn:hover {
    background: linear-gradient(90deg, rgba(255,102,0,0.15) 0%, rgba(255,102,0,0.05) 100%);
    color:#ff6600; border-left:2px solid #ff6600;
    text-shadow: 0 0 20px rgba(255,102,0,0.5);
  }
  .menu-btn:active { transform:scale(0.98); }

  .menu-footer {
    position:absolute; bottom:20px; font-size:11px; color:#333; letter-spacing:3px; z-index:2;
  }

  /* SETTINGS PANEL */
  #settingsPanel {
    position:fixed; inset:0; z-index:150; background:rgba(0,0,0,0.95);
    display:none; flex-direction:column; align-items:center; justify-content:center;
  }
  #settingsPanel.show { display:flex; }
  .settings-box {
    background: linear-gradient(180deg, #111 0%, #0a0a0a 100%);
    border:1px solid #222; padding:40px; min-width:400px;
  }
  .settings-box h2 { font-family:'Orbitron'; font-size:20px; color:#ff6600; margin-bottom:25px; letter-spacing:4px; }
  .setting-row { margin-bottom:18px; }
  .setting-row label { display:block; font-size:12px; color:#888; margin-bottom:6px; letter-spacing:2px; text-transform:uppercase; }
  .setting-row input[type=text], .setting-row input[type=number] {
    width:100%; background:#0a0a0a; border:1px solid #333; color:#fff; padding:10px;
    font-family:'Share Tech Mono'; font-size:14px; outline:none;
  }
  .setting-row input:focus { border-color:#ff6600; }
  .setting-row input[type=range] { width:100%; accent-color:#ff6600; }
  .settings-back {
    margin-top:20px; background:none; border:1px solid #333; color:#888; padding:10px 30px;
    cursor:pointer; font-family:'Share Tech Mono'; font-size:13px; letter-spacing:2px;
    transition:all 0.2s;
  }
  .settings-back:hover { border-color:#ff6600; color:#ff6600; }

  /* HUD */
  #hud { position:fixed; inset:0; z-index:50; pointer-events:none; }
  #hud.hidden { display:none; }

  .crosshair {
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
  }
  .crosshair div { position:absolute; background:#0f0; }
  .ch-top { width:2px; height:10px; left:-1px; top:-16px; }
  .ch-bot { width:2px; height:10px; left:-1px; top:6px; }
  .ch-left { width:10px; height:2px; left:-16px; top:-1px; }
  .ch-right { width:10px; height:2px; left:6px; top:-1px; }
  .ch-dot { width:2px; height:2px; left:-1px; top:-1px; background:rgba(0,255,0,0.5); }

  .hp-bar {
    position:absolute; bottom:20px; left:20px;
    display:flex; align-items:center; gap:12px;
  }
  .hp-icon { font-size:28px; }
  .hp-num { font-family:'Orbitron'; font-size:32px; font-weight:700; }
  .hp-num.low { color:#ff3333; }
  .hp-num.mid { color:#ffaa00; }
  .hp-num.ok { color:#fff; }

  .ammo-bar {
    position:absolute; bottom:20px; right:20px;
    display:flex; align-items:baseline; gap:6px;
  }
  .ammo-bar.hidden { display:none; }
  .ammo-clip { font-family:'Orbitron'; font-size:32px; font-weight:700; }
  .ammo-sep { font-size:20px; color:#666; }
  .ammo-total { font-family:'Orbitron'; font-size:18px; color:#888; }

  .weapon-name {
    position:absolute; bottom:60px; right:20px;
    font-size:12px; color:#666; letter-spacing:3px; text-transform:uppercase;
  }

  .kill-feed {
    position:absolute; top:10px; right:10px;
    display:flex; flex-direction:column; gap:3px; align-items:flex-end;
  }
  .kill-entry {
    background:rgba(0,0,0,0.7); padding:4px 10px; font-size:12px;
    display:flex; gap:8px; align-items:center;
    animation: fadeKill 4s forwards;
    border-left:2px solid #ff6600;
  }
  @keyframes fadeKill { 0%,70%{opacity:1;} 100%{opacity:0;} }
  .kill-entry .killer { color:#ff6600; }
  .kill-entry .victim { color:#6cf; }
  .kill-entry .hs { color:#ff0; font-size:10px; }

  .hit-marker {
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); pointer-events:none; display:none;
  }
  .hit-marker.show { display:block; animation: hmPop 0.2s; }
  @keyframes hmPop { 0%{transform:translate(-50%,-50%) scale(1.5);opacity:1;} 100%{transform:translate(-50%,-50%) scale(1);opacity:0.8;} }
  .hm-line { position:absolute; background:#fff; }
  .hm-1 { width:12px; height:2px; transform:rotate(45deg); left:4px; top:-2px; }
  .hm-2 { width:12px; height:2px; transform:rotate(-45deg); left:4px; top:10px; }
  .hm-3 { width:12px; height:2px; transform:rotate(135deg); left:-6px; top:-2px; }
  .hm-4 { width:12px; height:2px; transform:rotate(-135deg); left:-6px; top:10px; }

  .dmg-overlay {
    position:fixed; inset:0; pointer-events:none; z-index:45;
    border:3px solid transparent; transition:border-color 0.1s;
  }
  .dmg-overlay.hit { border-color:rgba(255,0,0,0.6); }

  .death-screen {
    position:fixed; inset:0; z-index:60; background:rgba(100,0,0,0.5);
    display:none; align-items:center; justify-content:center; flex-direction:column;
  }
  .death-screen.show { display:flex; }
  .death-screen h2 { font-family:'Orbitron'; font-size:36px; color:#ff3333; }
  .death-screen p { color:#999; margin-top:10px; font-size:14px; }

  /* SCOREBOARD */
  #scoreboard {
    position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
    z-index:80; display:none; min-width:500px;
    background:rgba(0,0,0,0.92); border:1px solid #333;
  }
  #scoreboard.show { display:block; }
  .sb-header {
    background:#111; padding:12px 20px; font-family:'Orbitron'; font-size:14px;
    color:#ff6600; letter-spacing:4px; border-bottom:1px solid #333;
  }
  .sb-table { width:100%; border-collapse:collapse; }
  .sb-table th {
    text-align:left; padding:8px 15px; font-size:11px; color:#666;
    border-bottom:1px solid #222; letter-spacing:2px;
  }
  .sb-table td { padding:6px 15px; font-size:13px; border-bottom:1px solid #111; }
  .sb-table tr.me td { color:#ff6600; }
  .sb-table .t-team { width:30px; }
  .team-t { color:#f4a460; }
  .team-ct { color:#6ca6cd; }

  /* CHAT */
  #chatBox {
    position:fixed; bottom:80px; left:20px; z-index:70; width:350px;
  }
  .chat-msgs {
    max-height:150px; overflow:hidden; display:flex; flex-direction:column; gap:2px;
    margin-bottom:5px;
  }
  .chat-msg {
    font-size:12px; background:rgba(0,0,0,0.5); padding:3px 8px;
    animation: fadeMsg 10s forwards;
  }
  @keyframes fadeMsg { 0%,80%{opacity:1;} 100%{opacity:0;} }
  .chat-msg .cn { color:#ff6600; }
  .chat-input {
    display:none; background:rgba(0,0,0,0.8); border:1px solid #333;
    color:#fff; padding:6px 10px; width:100%; font-family:'Share Tech Mono';
    font-size:13px; outline:none;
  }
  .chat-input.show { display:block; pointer-events:auto; }

  /* RADAR */
  .radar {
    position:absolute; top:15px; left:15px; width:140px; height:140px;
    background:rgba(0,20,0,0.7); border:1px solid #1a3a1a; border-radius:4px;
    overflow:hidden;
  }
  .radar-center { position:absolute; top:50%; left:50%; width:4px; height:4px; background:#0f0; border-radius:50%; transform:translate(-50%,-50%); z-index:2; }
  .radar canvas { position:absolute; inset:0; }

  .conn-status {
    position:absolute; top:15px; left:50%; transform:translateX(-50%);
    font-size:11px; letter-spacing:2px; padding:4px 12px;
    background:rgba(0,0,0,0.6);
  }
  .conn-status.ok { color:#0f0; }
  .conn-status.err { color:#f33; }

  /* GUN FLASH */
  .muzzle-flash {
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    width:60px; height:60px; border-radius:50%;
    background:radial-gradient(circle, rgba(255,200,50,0.8), transparent);
    display:none; pointer-events:none;
  }
  .muzzle-flash.show { display:block; animation: flash 0.05s; }
  @keyframes flash { 0%{opacity:1;transform:translate(-50%,-50%) scale(1.5);} 100%{opacity:0;} }
</style>
</head>
<body>

<!-- MAIN MENU -->
<div id="menu">
  <div class="menu-bg-effect"></div>
  <div class="menu-lines"></div>
  <div class="logo-container">
    <div class="logo-sub">★ TACTICAL SHOOTER ★</div>
    <div class="logo-main">MAXIS STRIKE</div>
    <div class="logo-edition">MULTIPLAYER EDITION v2.0</div>
  </div>
  <div class="menu-buttons">
    <button class="menu-btn" onclick="connectAndPlay()">► PLAY</button>
    <button class="menu-btn" onclick="showSettings()">⚙ SETTINGS</button>
    <button class="menu-btn" onclick="showControls()">⌨ CONTROLS</button>
    <button class="menu-btn" onclick="showAbout()">ℹ ABOUT</button>
  </div>
  <div class="menu-footer">© 2024 MAXIS STRIKE — ALL RIGHTS RESERVED</div>
</div>

<!-- SETTINGS -->
<div id="settingsPanel">
  <div class="settings-box">
    <h2>⚙ SETTINGS</h2>
    <div class="setting-row">
      <label>Player Name</label>
      <input type="text" id="playerName" value="Player" maxlength="16">
    </div>
    <div class="setting-row">
      <label>Mouse Sensitivity: <span id="sensVal">3.0</span></label>
      <input type="range" id="sensitivity" min="0.5" max="10" step="0.5" value="3" oninput="document.getElementById('sensVal').textContent=this.value">
    </div>
    <div class="setting-row">
      <label>FOV: <span id="fovVal">75</span></label>
      <input type="range" id="fovSetting" min="60" max="110" step="5" value="75" oninput="document.getElementById('fovVal').textContent=this.value">
    </div>
    <div class="setting-row">
      <label>Server Address (auto-detected)</label>
      <input type="text" id="serverAddr" value="" readonly style="opacity:0.6">
    </div>
    <div class="setting-row">
      <label>Volume: <span id="volVal">50</span>%</label>
      <input type="range" id="volume" min="0" max="100" step="5" value="50" oninput="document.getElementById('volVal').textContent=this.value">
    </div>
    <button class="settings-back" onclick="hideSettings()">← BACK</button>
  </div>
</div>

<!-- HUD -->
<div id="hud" class="hidden">
  <div class="crosshair" id="crosshair">
    <div class="ch-top"></div>
    <div class="ch-bot"></div>
    <div class="ch-left"></div>
    <div class="ch-right"></div>
    <div class="ch-dot"></div>
  </div>

  <div class="hp-bar">
    <span class="hp-icon">✚</span>
    <span class="hp-num ok" id="hpNum">100</span>
  </div>

  <div class="ammo-bar" id="ammoBar">
    <span class="ammo-clip" id="ammoClip">30</span>
    <span class="ammo-sep">/</span>
    <span class="ammo-total" id="ammoTotal">90</span>
  </div>
  <div class="weapon-name" id="weaponName">AK-47</div>

  <div class="kill-feed" id="killFeed"></div>

  <div class="hit-marker" id="hitMarker">
    <div class="hm-line hm-1"></div>
    <div class="hm-line hm-2"></div>
    <div class="hm-line hm-3"></div>
    <div class="hm-line hm-4"></div>
  </div>

  <div class="muzzle-flash" id="muzzleFlash"></div>

  <div class="radar">
    <canvas id="radarCanvas" width="140" height="140"></canvas>
    <div class="radar-center"></div>
  </div>

  <div class="conn-status ok" id="connStatus">CONNECTED</div>
</div>

<div class="dmg-overlay" id="dmgOverlay"></div>
<div class="death-screen" id="deathScreen">
  <h2>YOU DIED</h2>
  <p>Respawning in 3 seconds...</p>
</div>
<div id="scoreboard">
  <div class="sb-header">SCOREBOARD</div>
  <table class="sb-table">
    <thead><tr><th class="t-team"></th><th>NAME</th><th>K</th><th>D</th><th>HP</th></tr></thead>
    <tbody id="sbBody"></tbody>
  </table>
</div>
<div id="chatBox">
  <div class="chat-msgs" id="chatMsgs"></div>
  <input class="chat-input" id="chatInput" placeholder="Type message..." maxlength="100">
</div>

<!-- THREE.JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ═══════════════════════════════════════════
// MAXIS STRIKE - Full 3D FPS Client v2.0
// ═══════════════════════════════════════════

// === AUDIO ENGINE ===
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx;
function ensureAudio() { if(!audioCtx) audioCtx = new AudioCtx(); }

function playShoot(weapon) {
  ensureAudio();
  const vol = parseInt(document.getElementById('volume').value) / 100;
  
  if(weapon === 'knife') {
    // Knife swing sound
    const osc = audioCtx.createOscillator();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(300, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.15);
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.1 * vol, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
    osc.connect(g); g.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.15);
    return;
  }
  
  const g = audioCtx.createGain(); g.gain.value = 0.15 * vol; g.connect(audioCtx.destination);
  const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.08, audioCtx.sampleRate);
  const d = buf.getChannelData(0);
  for(let i=0;i<d.length;i++) d[i] = (Math.random()*2-1) * Math.pow(1 - i/d.length, 3);
  const s = audioCtx.createBufferSource(); s.buffer = buf; s.connect(g); s.start();
  const osc = audioCtx.createOscillator(); osc.frequency.value = weapon === 'deagle' ? 60 : 80;
  const g2 = audioCtx.createGain(); g2.gain.value = 0.2 * vol; g2.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime+0.1);
  osc.connect(g2); g2.connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime+0.1);
}

function playHit() {
  ensureAudio();
  const vol = parseInt(document.getElementById('volume').value) / 100;
  const osc = audioCtx.createOscillator(); osc.type='sine'; osc.frequency.value=800;
  const g = audioCtx.createGain(); g.gain.value=0.1*vol; g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+0.1);
  osc.connect(g); g.connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime+0.1);
}

function playDeath() {
  ensureAudio();
  const vol = parseInt(document.getElementById('volume').value) / 100;
  const osc = audioCtx.createOscillator(); osc.type='sawtooth'; osc.frequency.value=200;
  osc.frequency.exponentialRampToValueAtTime(50,audioCtx.currentTime+0.5);
  const g = audioCtx.createGain(); g.gain.value=0.15*vol; g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+0.5);
  osc.connect(g); g.connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime+0.5);
}

function playStep() {
  ensureAudio();
  const vol = parseInt(document.getElementById('volume').value) / 100;
  const buf = audioCtx.createBuffer(1, audioCtx.sampleRate*0.05, audioCtx.sampleRate);
  const d = buf.getChannelData(0);
  for(let i=0;i<d.length;i++) d[i] = (Math.random()*2-1)*Math.pow(1-i/d.length,5)*0.3;
  const s = audioCtx.createBufferSource(); s.buffer=buf;
  const g = audioCtx.createGain(); g.gain.value=0.05*vol;
  const f = audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=500;
  s.connect(f); f.connect(g); g.connect(audioCtx.destination); s.start();
}

// === GAME STATE ===
let ws = null;
let myId = null;
let myPlayer = null;
let players = {};
let scene, camera, renderer;
let moveState = { forward:0, back:0, left:0, right:0, jump:false };
let velocity = new THREE.Vector3();
let yaw = 0, pitch = 0;
let onGround = true;
let weapons = {
  ak47: { name:'AK-47', clip:30, maxClip:30, total:90, fireRate:100, reloading:false, reloadTime:2500, damage:27, auto:true },
  deagle: { name:'Desert Eagle', clip:7, maxClip:7, total:35, fireRate:300, reloading:false, reloadTime:1800, damage:45, auto:false },
  knife: { name:'Knife', clip:0, maxClip:0, total:0, fireRate:500, reloading:false, reloadTime:0, damage:50, auto:false, melee:true }
};
let currentWeapon = 'ak47';
let lastShot = 0;
let canShoot = true;
let isAlive = true;
let hp = 100;
let otherPlayerMeshes = {};
let gunMesh = null;
let shooting = false;
let stepTimer = 0;
let chatOpen = false;

// Map elements for collision
let mapBoxes = [];

// Texture cache
let textures = {};

// === CREATE TEXTURES ===
function createTextures() {
  // Ground texture - detailed sand/dirt
  const groundCanvas = document.createElement('canvas');
  groundCanvas.width = 512; groundCanvas.height = 512;
  const gctx = groundCanvas.getContext('2d');
  
  // Base color
  gctx.fillStyle = '#9B8B6B';
  gctx.fillRect(0, 0, 512, 512);
  
  // Add noise layers
  for(let i = 0; i < 8000; i++) {
    const x = Math.random() * 512;
    const y = Math.random() * 512;
    const size = 1 + Math.random() * 4;
    const brightness = 120 + Math.random() * 80;
    gctx.fillStyle = `rgba(${brightness}, ${brightness * 0.85}, ${brightness * 0.6}, 0.4)`;
    gctx.fillRect(x, y, size, size);
  }
  
  // Add some pebbles
  for(let i = 0; i < 200; i++) {
    const x = Math.random() * 512;
    const y = Math.random() * 512;
    const size = 2 + Math.random() * 6;
    gctx.fillStyle = `rgba(${80 + Math.random() * 40}, ${70 + Math.random() * 30}, ${50 + Math.random() * 20}, 0.6)`;
    gctx.beginPath();
    gctx.ellipse(x, y, size, size * 0.7, Math.random() * Math.PI, 0, Math.PI * 2);
    gctx.fill();
  }
  
  textures.ground = new THREE.CanvasTexture(groundCanvas);
  textures.ground.wrapS = textures.ground.wrapT = THREE.RepeatWrapping;
  textures.ground.repeat.set(20, 20);
  
  // Wall texture - brick pattern
  const wallCanvas = document.createElement('canvas');
  wallCanvas.width = 256; wallCanvas.height = 256;
  const wctx = wallCanvas.getContext('2d');
  
  // Base
  wctx.fillStyle = '#8B7355';
  wctx.fillRect(0, 0, 256, 256);
  
  // Bricks
  const brickH = 32;
  const brickW = 64;
  for(let row = 0; row < 256 / brickH; row++) {
    const offset = (row % 2) * (brickW / 2);
    for(let col = -1; col < 256 / brickW + 1; col++) {
      const x = col * brickW + offset;
      const y = row * brickH;
      
      // Brick color variation
      const r = 130 + Math.random() * 30;
      const g = 100 + Math.random() * 25;
      const b = 70 + Math.random() * 20;
      wctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
      wctx.fillRect(x + 2, y + 2, brickW - 4, brickH - 4);
      
      // Brick highlight
      wctx.fillStyle = `rgba(255, 255, 255, 0.1)`;
      wctx.fillRect(x + 2, y + 2, brickW - 4, 2);
      
      // Brick shadow
      wctx.fillStyle = `rgba(0, 0, 0, 0.2)`;
      wctx.fillRect(x + 2, y + brickH - 4, brickW - 4, 2);
    }
  }
  
  // Mortar lines
  wctx.strokeStyle = '#5A4A3A';
  wctx.lineWidth = 3;
  for(let y = 0; y <= 256; y += brickH) {
    wctx.beginPath();
    wctx.moveTo(0, y);
    wctx.lineTo(256, y);
    wctx.stroke();
  }
  
  textures.wall = new THREE.CanvasTexture(wallCanvas);
  textures.wall.wrapS = textures.wall.wrapT = THREE.RepeatWrapping;
  
  // Crate texture - wooden
  const crateCanvas = document.createElement('canvas');
  crateCanvas.width = 128; crateCanvas.height = 128;
  const cctx = crateCanvas.getContext('2d');
  
  // Wood base
  cctx.fillStyle = '#A0722A';
  cctx.fillRect(0, 0, 128, 128);
  
  // Wood grain
  for(let i = 0; i < 30; i++) {
    const y = Math.random() * 128;
    cctx.strokeStyle = `rgba(${60 + Math.random() * 40}, ${40 + Math.random() * 30}, ${20}, 0.3)`;
    cctx.lineWidth = 1 + Math.random() * 2;
    cctx.beginPath();
    cctx.moveTo(0, y);
    for(let x = 0; x < 128; x += 10) {
      cctx.lineTo(x, y + (Math.random() - 0.5) * 4);
    }
    cctx.stroke();
  }
  
  // Border
  cctx.strokeStyle = '#5A4020';
  cctx.lineWidth = 6;
  cctx.strokeRect(3, 3, 122, 122);
  
  // Cross planks
  cctx.lineWidth = 8;
  cctx.beginPath();
  cctx.moveTo(10, 10);
  cctx.lineTo(118, 118);
  cctx.stroke();
  cctx.beginPath();
  cctx.moveTo(118, 10);
  cctx.lineTo(10, 118);
  cctx.stroke();
  
  // Corner brackets
  cctx.fillStyle = '#3A3A3A';
  const cornerSize = 15;
  [[0,0], [128-cornerSize,0], [0,128-cornerSize], [128-cornerSize,128-cornerSize]].forEach(([x,y]) => {
    cctx.fillRect(x, y, cornerSize, cornerSize);
    cctx.fillStyle = '#5A5A5A';
    cctx.fillRect(x+2, y+2, cornerSize-4, cornerSize-4);
    cctx.fillStyle = '#3A3A3A';
  });
  
  textures.crate = new THREE.CanvasTexture(crateCanvas);
  
  // Concrete texture
  const concreteCanvas = document.createElement('canvas');
  concreteCanvas.width = 256; concreteCanvas.height = 256;
  const ccctx = concreteCanvas.getContext('2d');
  
  ccctx.fillStyle = '#707070';
  ccctx.fillRect(0, 0, 256, 256);
  
  for(let i = 0; i < 5000; i++) {
    const x = Math.random() * 256;
    const y = Math.random() * 256;
    const b = 90 + Math.random() * 50;
    ccctx.fillStyle = `rgba(${b}, ${b}, ${b}, 0.3)`;
    ccctx.fillRect(x, y, 1 + Math.random() * 3, 1 + Math.random() * 3);
  }
  
  // Cracks
  for(let i = 0; i < 10; i++) {
    ccctx.strokeStyle = `rgba(40, 40, 40, ${0.2 + Math.random() * 0.3})`;
    ccctx.lineWidth = 0.5 + Math.random();
    ccctx.beginPath();
    let x = Math.random() * 256;
    let y = Math.random() * 256;
    ccctx.moveTo(x, y);
    for(let j = 0; j < 5; j++) {
      x += (Math.random() - 0.5) * 40;
      y += Math.random() * 30;
      ccctx.lineTo(x, y);
    }
    ccctx.stroke();
  }
  
  textures.concrete = new THREE.CanvasTexture(concreteCanvas);
  textures.concrete.wrapS = textures.concrete.wrapT = THREE.RepeatWrapping;
  
  // Metal texture for barrels
  const metalCanvas = document.createElement('canvas');
  metalCanvas.width = 64; metalCanvas.height = 64;
  const mctx = metalCanvas.getContext('2d');
  
  const gradient = mctx.createLinearGradient(0, 0, 64, 0);
  gradient.addColorStop(0, '#3A3A3A');
  gradient.addColorStop(0.3, '#5A5A5A');
  gradient.addColorStop(0.5, '#4A4A4A');
  gradient.addColorStop(0.7, '#5A5A5A');
  gradient.addColorStop(1, '#3A3A3A');
  mctx.fillStyle = gradient;
  mctx.fillRect(0, 0, 64, 64);
  
  // Rust spots
  for(let i = 0; i < 20; i++) {
    mctx.fillStyle = `rgba(139, 69, 19, ${0.2 + Math.random() * 0.3})`;
    mctx.beginPath();
    mctx.arc(Math.random() * 64, Math.random() * 64, 2 + Math.random() * 4, 0, Math.PI * 2);
    mctx.fill();
  }
  
  textures.metal = new THREE.CanvasTexture(metalCanvas);
  textures.metal.wrapS = textures.metal.wrapT = THREE.RepeatWrapping;
}

// === INIT 3D ===
function init3D() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x6B8CBA);
  scene.fog = new THREE.Fog(0x6B8CBA, 60, 150);

  const fov = parseInt(document.getElementById('fovSetting').value) || 75;
  camera = new THREE.PerspectiveCamera(fov, window.innerWidth/window.innerHeight, 0.1, 500);
  camera.position.set(0, 1.7, 0);

  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.prepend(renderer.domElement);

  // Lights
  const amb = new THREE.AmbientLight(0x8899aa, 0.5);
  scene.add(amb);

  const sun = new THREE.DirectionalLight(0xffeedd, 1.2);
  sun.position.set(40, 60, 30);
  sun.castShadow = true;
  sun.shadow.mapSize.width = 2048;
  sun.shadow.mapSize.height = 2048;
  sun.shadow.camera.near = 0.5;
  sun.shadow.camera.far = 200;
  sun.shadow.camera.left = -70;
  sun.shadow.camera.right = 70;
  sun.shadow.camera.top = 70;
  sun.shadow.camera.bottom = -70;
  scene.add(sun);

  const hemi = new THREE.HemisphereLight(0x87CEEB, 0x5a4a3a, 0.4);
  scene.add(hemi);

  createTextures();
  buildMap();
  createGunModel(currentWeapon);

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

// === BUILD MAP ===
function buildMap() {
  // Ground
  const groundGeo = new THREE.PlaneGeometry(120, 120);
  const groundMat = new THREE.MeshLambertMaterial({ map: textures.ground });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.y = 0;
  ground.receiveShadow = true;
  scene.add(ground);

  function addWall(x,y,z,w,h,d,tex) {
    const geo = new THREE.BoxGeometry(w,h,d);
    const t = (tex || textures.wall).clone();
    t.repeat.set(w/4, h/4);
    const mat = new THREE.MeshLambertMaterial({ map: t });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x,y,z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    mapBoxes.push({ mesh, min:{x:x-w/2,y:y-h/2,z:z-d/2}, max:{x:x+w/2,y:y+h/2,z:z+d/2} });
    return mesh;
  }

  function addCrate(x,z,s) {
    s = s||2;
    const geo = new THREE.BoxGeometry(s,s,s);
    const mat = new THREE.MeshLambertMaterial({ map: textures.crate });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x, s/2, z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    mapBoxes.push({ mesh, min:{x:x-s/2,y:0,z:z-s/2}, max:{x:x+s/2,y:s,z:z+s/2} });
  }

  // Perimeter walls
  addWall(0, 3, -55, 120, 6, 2, textures.concrete);
  addWall(0, 3, 55, 120, 6, 2, textures.concrete);
  addWall(-55, 3, 0, 2, 6, 120, textures.concrete);
  addWall(55, 3, 0, 2, 6, 120, textures.concrete);

  // Central building - moved away from center spawn
  addWall(0, 2.5, -18, 12, 5, 1);
  addWall(0, 2.5, -2, 12, 5, 1);
  addWall(-6, 2.5, -10, 1, 5, 16);
  addWall(6, 2.5, -10, 1, 5, 16);

  // A site platform
  addWall(-30, 0.5, -30, 14, 1, 14, textures.concrete);
  addWall(-30, 2.5, -37, 14, 5, 1);
  addWall(-37, 2.5, -30, 1, 5, 14);

  // B site platform
  addWall(30, 0.5, 30, 14, 1, 14, textures.concrete);
  addWall(30, 2.5, 37, 14, 5, 1);
  addWall(37, 2.5, 30, 1, 5, 14);

  // Corridors
  addWall(-20, 2, -20, 8, 4, 1);
  addWall(-20, 2, -15, 1, 4, 10);
  addWall(20, 2, 20, 8, 4, 1);
  addWall(20, 2, 15, 1, 4, 10);

  // Crates scattered - away from center
  addCrate(-15, -15, 2);
  addCrate(-13, -15, 2);
  addCrate(-14, -13, 2);
  addCrate(15, 15, 2);
  addCrate(17, 15, 2);
  addCrate(-35, -20, 2.5);
  addCrate(-35, -17, 2.5);
  addCrate(35, 20, 2.5);
  addCrate(35, 17, 2.5);
  addCrate(-25, 15, 2);
  addCrate(25, -15, 2);
  addCrate(-45, -45, 3);
  addCrate(45, 45, 3);
  addCrate(-40, 35, 2);
  addCrate(40, -35, 2);

  // Cover walls - mid (away from center)
  addWall(-8, 1.5, -25, 6, 3, 0.5);
  addWall(8, 1.5, 25, 6, 3, 0.5);
  addWall(-25, 1.5, -8, 0.5, 3, 6);
  addWall(25, 1.5, 8, 0.5, 3, 6);

  // Barrel-like cylinders
  function addBarrel(x,z) {
    const geo = new THREE.CylinderGeometry(0.5, 0.5, 1.2, 12);
    const mat = new THREE.MeshLambertMaterial({ map: textures.metal });
    const m = new THREE.Mesh(geo, mat);
    m.position.set(x, 0.6, z);
    m.castShadow = true;
    scene.add(m);
    mapBoxes.push({ mesh:m, min:{x:x-0.5,y:0,z:z-0.5}, max:{x:x+0.5,y:1.2,z:z+0.5} });
  }
  addBarrel(-17, 12); addBarrel(-16, 12.5); addBarrel(17, -12); addBarrel(16, -12.5);
  addBarrel(-43, 5); addBarrel(43, -5);

  // Skybox feel - distant buildings
  for(let i=0; i<24; i++) {
    const bGeo = new THREE.BoxGeometry(8+Math.random()*15, 15+Math.random()*30, 8+Math.random()*15);
    const b = 0.25 + Math.random() * 0.15;
    const bMat = new THREE.MeshLambertMaterial({ color: new THREE.Color(b, b * 0.95, b * 0.9) });
    const bld = new THREE.Mesh(bGeo, bMat);
    const angle = (i/24)*Math.PI*2;
    bld.position.set(Math.cos(angle)*100, bGeo.parameters.height/2, Math.sin(angle)*100);
    scene.add(bld);
  }
}

// === GUN MODELS ===
function createGunModel(weaponType) {
  // Remove old gun
  if(gunMesh) {
    camera.remove(gunMesh);
  }
  
  gunMesh = new THREE.Group();
  
  if(weaponType === 'ak47') {
    // AK-47 Model
    // Main receiver
    const receiver = new THREE.Mesh(
      new THREE.BoxGeometry(0.05, 0.07, 0.4),
      new THREE.MeshLambertMaterial({ color: 0x2a2a2a })
    );
    gunMesh.add(receiver);
    
    // Barrel
    const barrel = new THREE.Mesh(
      new THREE.CylinderGeometry(0.015, 0.015, 0.35, 8),
      new THREE.MeshLambertMaterial({ color: 0x1a1a1a })
    );
    barrel.rotation.x = Math.PI/2;
    barrel.position.set(0, 0.015, -0.35);
    gunMesh.add(barrel);
    
    // Gas tube
    const gasTube = new THREE.Mesh(
      new THREE.CylinderGeometry(0.012, 0.012, 0.2, 6),
      new THREE.MeshLambertMaterial({ color: 0x333333 })
    );
    gasTube.rotation.x = Math.PI/2;
    gasTube.position.set(0, 0.04, -0.25);
    gunMesh.add(gasTube);
    
    // Wooden handguard
    const handguard = new THREE.Mesh(
      new THREE.BoxGeometry(0.045, 0.05, 0.18),
      new THREE.MeshLambertMaterial({ color: 0x8B4513 })
    );
    handguard.position.set(0, 0, -0.2);
    gunMesh.add(handguard);
    
    // Magazine (curved)
    const mag = new THREE.Mesh(
      new THREE.BoxGeometry(0.035, 0.18, 0.06),
      new THREE.MeshLambertMaterial({ color: 0x8B4513 })
    );
    mag.position.set(0, -0.12, 0);
    mag.rotation.x = 0.2;
    gunMesh.add(mag);
    
    // Stock (wooden)
    const stock = new THREE.Mesh(
      new THREE.BoxGeometry(0.04, 0.05, 0.25),
      new THREE.MeshLambertMaterial({ color: 0x8B4513 })
    );
    stock.position.set(0, -0.01, 0.28);
    gunMesh.add(stock);
    
    // Stock butt
    const stockButt = new THREE.Mesh(
      new THREE.BoxGeometry(0.04, 0.08, 0.04),
      new THREE.MeshLambertMaterial({ color: 0x654321 })
    );
    stockButt.position.set(0, -0.015, 0.42);
    gunMesh.add(stockButt);
    
    // Grip
    const grip = new THREE.Mesh(
      new THREE.BoxGeometry(0.03, 0.09, 0.035),
      new THREE.MeshLambertMaterial({ color: 0x654321 })
    );
    grip.position.set(0, -0.07, 0.1);
    grip.rotation.x = -0.3;
    gunMesh.add(grip);
    
    // Front sight
    const frontSight = new THREE.Mesh(
      new THREE.BoxGeometry(0.01, 0.025, 0.01),
      new THREE.MeshLambertMaterial({ color: 0x1a1a1a })
    );
    frontSight.position.set(0, 0.05, -0.45);
    gunMesh.add(frontSight);
    
    gunMesh.position.set(0.22, -0.18, -0.35);
    
  } else if(weaponType === 'deagle') {
    // Desert Eagle Model
    // Slide
    const slide = new THREE.Mesh(
      new THREE.BoxGeometry(0.035, 0.05, 0.25),
      new THREE.MeshLambertMaterial({ color: 0xC0C0C0 })
    );
    gunMesh.add(slide);
    
    // Barrel
    const barrel = new THREE.Mesh(
      new THREE.CylinderGeometry(0.015, 0.015, 0.15, 8),
      new THREE.MeshLambertMaterial({ color: 0x888888 })
    );
    barrel.rotation.x = Math.PI/2;
    barrel.position.set(0, 0, -0.18);
    gunMesh.add(barrel);
    
    // Frame
    const frame = new THREE.Mesh(
      new THREE.BoxGeometry(0.03, 0.04, 0.18),
      new THREE.MeshLambertMaterial({ color: 0x2a2a2a })
    );
    frame.position.set(0, -0.03, 0.02);
    gunMesh.add(frame);
    
    // Grip
    const grip = new THREE.Mesh(
      new THREE.BoxGeometry(0.03, 0.1, 0.04),
      new THREE.MeshLambertMaterial({ color: 0x1a1a1a })
    );
    grip.position.set(0, -0.08, 0.08);
    grip.rotation.x = -0.15;
    gunMesh.add(grip);
    
    // Trigger guard
    const triggerGuard = new THREE.Mesh(
      new THREE.TorusGeometry(0.02, 0.004, 6, 8, Math.PI),
      new THREE.MeshLambertMaterial({ color: 0x2a2a2a })
    );
    triggerGuard.rotation.x = Math.PI/2;
    triggerGuard.rotation.z = Math.PI;
    triggerGuard.position.set(0, -0.045, 0.02);
    gunMesh.add(triggerGuard);
    
    // Magazine
    const mag = new THREE.Mesh(
      new THREE.BoxGeometry(0.025, 0.08, 0.03),
      new THREE.MeshLambertMaterial({ color: 0x333333 })
    );
    mag.position.set(0, -0.1, 0.05);
    gunMesh.add(mag);
    
    // Front sight
    const frontSight = new THREE.Mesh(
      new THREE.BoxGeometry(0.008, 0.015, 0.008),
      new THREE.MeshLambertMaterial({ color: 0x1a1a1a })
    );
    frontSight.position.set(0, 0.035, -0.1);
    gunMesh.add(frontSight);
    
    gunMesh.position.set(0.18, -0.15, -0.28);
    
  } else if(weaponType === 'knife') {
    // Knife Model
    // Blade
    const bladeShape = new THREE.Shape();
    bladeShape.moveTo(0, 0);
    bladeShape.lineTo(0.18, 0.01);
    bladeShape.lineTo(0.22, 0);
    bladeShape.lineTo(0.18, -0.01);
    bladeShape.lineTo(0, -0.015);
    bladeShape.lineTo(0, 0);
    
    const bladeGeo = new THREE.ExtrudeGeometry(bladeShape, { depth: 0.008, bevelEnabled: false });
    const blade = new THREE.Mesh(bladeGeo, new THREE.MeshLambertMaterial({ color: 0xCCCCCC }));
    blade.rotation.y = -Math.PI/2;
    blade.position.set(0.004, 0, -0.22);
    gunMesh.add(blade);
    
    // Blade edge highlight
    const edge = new THREE.Mesh(
      new THREE.BoxGeometry(0.002, 0.003, 0.2),
      new THREE.MeshLambertMaterial({ color: 0xFFFFFF })
    );
    edge.position.set(0, -0.008, -0.15);
    gunMesh.add(edge);
    
    // Guard
    const guard = new THREE.Mesh(
      new THREE.BoxGeometry(0.04, 0.025, 0.015),
      new THREE.MeshLambertMaterial({ color: 0x333333 })
    );
    guard.position.set(0, 0, -0.02);
    gunMesh.add(guard);
    
    // Handle
    const handle = new THREE.Mesh(
      new THREE.BoxGeometry(0.025, 0.03, 0.12),
      new THREE.MeshLambertMaterial({ color: 0x2a2a2a })
    );
    handle.position.set(0, 0, 0.04);
    gunMesh.add(handle);
    
    // Handle grip lines
    for(let i = 0; i < 4; i++) {
      const line = new THREE.Mesh(
        new THREE.BoxGeometry(0.026, 0.003, 0.008),
        new THREE.MeshLambertMaterial({ color: 0x1a1a1a })
      );
      line.position.set(0, 0.017, 0.01 + i * 0.022);
      gunMesh.add(line);
    }
    
    // Pommel
    const pommel = new THREE.Mesh(
      new THREE.BoxGeometry(0.03, 0.035, 0.02),
      new THREE.MeshLambertMaterial({ color: 0x333333 })
    );
    pommel.position.set(0, 0, 0.11);
    gunMesh.add(pommel);
    
    gunMesh.position.set(0.2, -0.1, -0.25);
    gunMesh.rotation.x = 0.3;
  }
  
  camera.add(gunMesh);
  if(!camera.parent) scene.add(camera);
}

// === MULTIPLAYER ===
function getWebSocketURL() {
  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  const host = window.location.host;
  if (window.location.protocol === 'file:') {
    return 'ws://localhost:3000';
  }
  return `${protocol}//${host}`;
}

document.addEventListener('DOMContentLoaded', () => {
  document.getElementById('serverAddr').value = getWebSocketURL();
});

function connectAndPlay() {
  const addr = getWebSocketURL();
  const name = document.getElementById('playerName').value || 'Player';

  document.getElementById('connStatus').className = 'conn-status err';
  document.getElementById('connStatus').textContent = 'CONNECTING...';

  try {
    ws = new WebSocket(addr);
  } catch(e) {
    alert('Cannot connect to server!\nMake sure server.js is running:\nnpm install ws && node server.js');
    return;
  }

  ws.onopen = () => {
    console.log('Connected to MAXIS STRIKE server');
    document.getElementById('connStatus').className = 'conn-status ok';
    document.getElementById('connStatus').textContent = 'CONNECTED';
    ws.send(JSON.stringify({ type:'setName', name }));
    startGame();
  };

  ws.onmessage = (e) => {
    const data = JSON.parse(e.data);
    handleServerMessage(data);
  };

  ws.onclose = () => {
    document.getElementById('connStatus').className = 'conn-status err';
    document.getElementById('connStatus').textContent = 'DISCONNECTED';
  };

  ws.onerror = () => {
    alert('Connection failed!\nStart the server first:\nnpm install ws && node server.js');
    document.getElementById('connStatus').className = 'conn-status err';
    document.getElementById('connStatus').textContent = 'ERROR';
  };
}

function handleServerMessage(data) {
  switch(data.type) {
    case 'init':
      myId = data.id;
      myPlayer = data.player;
      players = data.players;
      camera.position.set(data.player.x, data.player.y, data.player.z);
      for(let pid in players) {
        if(pid != myId) createPlayerMesh(pid, players[pid]);
      }
      break;

    case 'playerJoin':
      players[data.player.id] = data.player;
      createPlayerMesh(data.player.id, data.player);
      addChat('SERVER', data.player.name + ' joined the game');
      break;

    case 'playerLeave':
      delete players[data.id];
      removePlayerMesh(data.id);
      addChat('SERVER', 'Player disconnected');
      break;

    case 'playerMove':
      if(data.id != myId && otherPlayerMeshes[data.id]) {
        const pm = otherPlayerMeshes[data.id];
        pm.targetPos = new THREE.Vector3(data.x, data.y - 1.7, data.z);
        pm.mesh.rotation.y = -data.ry;
      }
      if(players[data.id]) {
        players[data.id].x = data.x;
        players[data.id].y = data.y;
        players[data.id].z = data.z;
      }
      break;

    case 'playerShoot':
      if(data.id != myId) {
        playShoot(data.weapon || 'ak47');
        if(data.weapon !== 'knife') {
          showTracer(data.x, data.y, data.z, data.dx, data.dy, data.dz);
        }
      }
      break;

    case 'hit':
      hp = data.hp;
      updateHP();
      showDamage();
      playHit();
      break;

    case 'hitConfirm':
      showHitMarker();
      playHit();
      break;

    case 'kill':
      addKillFeed(data.killerId, data.victimId, data.weapon, data.headshot);
      if(data.victimId === myId) {
        isAlive = false;
        document.getElementById('deathScreen').classList.add('show');
        playDeath();
      }
      if(players[data.killerId]) players[data.killerId].kills = (players[data.killerId].kills||0)+1;
      if(players[data.victimId]) players[data.victimId].deaths = (players[data.victimId].deaths||0)+1;
      break;

    case 'respawn':
      if(data.id === myId) {
        isAlive = true;
        hp = 100;
        updateHP();
        camera.position.set(data.x, data.y, data.z);
        document.getElementById('deathScreen').classList.remove('show');
        resetAmmo();
      }
      if(players[data.id]) {
        players[data.id].alive = true;
        players[data.id].hp = 100;
        players[data.id].x = data.x;
        players[data.id].y = data.y;
        players[data.id].z = data.z;
      }
      break;

    case 'state':
      for(let pid in data.players) {
        players[pid] = data.players[pid];
        if(pid != myId && !otherPlayerMeshes[pid]) {
          createPlayerMesh(pid, data.players[pid]);
        }
      }
      for(let pid in otherPlayerMeshes) {
        if(!data.players[pid]) removePlayerMesh(pid);
      }
      break;

    case 'chat':
      addChat(data.name, data.msg);
      break;

    case 'nameChange':
      if(players[data.id]) players[data.id].name = data.name;
      break;
  }
}

function createPlayerMesh(id, pdata) {
  if(id == myId || otherPlayerMeshes[id]) return;

  const group = new THREE.Group();

  const isT = pdata.team === 'T';
  const bodyColor = isT ? 0xc4782a : 0x2a5a8a;
  const headColor = 0xdaa06d;

  // Body
  const bodyGeo = new THREE.BoxGeometry(0.6, 0.9, 0.4);
  const bodyMat = new THREE.MeshLambertMaterial({ color: bodyColor });
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.y = 0.95;
  body.castShadow = true;
  group.add(body);

  // Head
  const headGeo = new THREE.BoxGeometry(0.35, 0.35, 0.35);
  const headMat = new THREE.MeshLambertMaterial({ color: headColor });
  const head = new THREE.Mesh(headGeo, headMat);
  head.position.y = 1.6;
  head.castShadow = true;
  group.add(head);

  // Legs
  for(let side of [-1,1]) {
    const legGeo = new THREE.BoxGeometry(0.2, 0.5, 0.25);
    const legMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
    const leg = new THREE.Mesh(legGeo, legMat);
    leg.position.set(side*0.15, 0.25, 0);
    group.add(leg);
  }

  // Arms
  for(let side of [-1,1]) {
    const armGeo = new THREE.BoxGeometry(0.15, 0.6, 0.15);
    const armMat = new THREE.MeshLambertMaterial({ color: bodyColor });
    const arm = new THREE.Mesh(armGeo, armMat);
    arm.position.set(side*0.38, 1.0, -0.1);
    group.add(arm);
  }

  // Gun in hands
  const gunGeo = new THREE.BoxGeometry(0.05, 0.05, 0.4);
  const gunMat2 = new THREE.MeshLambertMaterial({ color:0x1a1a1a });
  const gun = new THREE.Mesh(gunGeo, gunMat2);
  gun.position.set(0.25, 1.0, -0.3);
  group.add(gun);

  // Name label
  const nameCanvas = document.createElement('canvas');
  nameCanvas.width = 256; nameCanvas.height = 64;
  const nctx = nameCanvas.getContext('2d');
  nctx.fillStyle = isT ? '#ff8800' : '#4488ff';
  nctx.font = 'bold 28px monospace';
  nctx.textAlign = 'center';
  nctx.fillText(pdata.name || 'Player', 128, 35);
  const nameTex = new THREE.CanvasTexture(nameCanvas);
  const nameSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: nameTex, transparent:true }));
  nameSprite.position.y = 2.0;
  nameSprite.scale.set(2, 0.5, 1);
  group.add(nameSprite);

  group.position.set(pdata.x || 0, 0, pdata.z || 0);
  scene.add(group);

  otherPlayerMeshes[id] = { mesh: group, targetPos: new THREE.Vector3(pdata.x||0, 0, pdata.z||0) };
}

function removePlayerMesh(id) {
  if(otherPlayerMeshes[id]) {
    scene.remove(otherPlayerMeshes[id].mesh);
    delete otherPlayerMeshes[id];
  }
}

// === GAME LOOP ===
let lastTime = 0;
function startGame() {
  if(!scene) init3D();
  document.getElementById('menu').classList.add('hidden');
  document.getElementById('hud').classList.remove('hidden');
  renderer.domElement.requestPointerLock();
  requestAnimationFrame(gameLoop);
}

function gameLoop(time) {
  requestAnimationFrame(gameLoop);
  const dt = Math.min((time - lastTime) / 1000, 0.1);
  lastTime = time;

  if(!isAlive) {
    renderer.render(scene, camera);
    return;
  }

  // Movement
  const speed = 12;
  const dir = new THREE.Vector3();
  const front = new THREE.Vector3();
  camera.getWorldDirection(front);
  front.y = 0; front.normalize();
  const right = new THREE.Vector3().crossVectors(front, new THREE.Vector3(0,1,0)).normalize();

  if(moveState.forward) dir.add(front);
  if(moveState.back) dir.sub(front);
  if(moveState.right) dir.add(right);
  if(moveState.left) dir.sub(right);
  if(dir.length() > 0) dir.normalize();

  velocity.x = dir.x * speed;
  velocity.z = dir.z * speed;

  // Gravity & Jump
  if(!onGround) {
    velocity.y -= 25 * dt;
  }
  if(moveState.jump && onGround) {
    velocity.y = 8;
    onGround = false;
  }

  // Apply velocity
  let newX = camera.position.x + velocity.x * dt;
  let newY = camera.position.y + velocity.y * dt;
  let newZ = camera.position.z + velocity.z * dt;

  // Collision detection
  const playerRadius = 0.4;
  const playerHeight = 1.7;

  for(const box of mapBoxes) {
    if(newX + playerRadius > box.min.x && newX - playerRadius < box.max.x &&
       camera.position.z + playerRadius > box.min.z && camera.position.z - playerRadius < box.max.z &&
       newY > box.min.y && newY - playerHeight < box.max.y) {
      if(camera.position.x <= box.min.x - playerRadius) newX = box.min.x - playerRadius;
      else if(camera.position.x >= box.max.x + playerRadius) newX = box.max.x + playerRadius;
    }
    if(newX + playerRadius > box.min.x && newX - playerRadius < box.max.x &&
       newZ + playerRadius > box.min.z && newZ - playerRadius < box.max.z &&
       newY > box.min.y && newY - playerHeight < box.max.y) {
      if(camera.position.z <= box.min.z - playerRadius) newZ = box.min.z - playerRadius;
      else if(camera.position.z >= box.max.z + playerRadius) newZ = box.max.z + playerRadius;
    }
  }

  // Ground collision
  let groundY = 1.7;
  for(const box of mapBoxes) {
    if(newX + playerRadius > box.min.x && newX - playerRadius < box.max.x &&
       newZ + playerRadius > box.min.z && newZ - playerRadius < box.max.z) {
      if(box.max.y < newY && box.max.y + playerHeight > newY) {
        groundY = Math.max(groundY, box.max.y + playerHeight);
      }
    }
  }

  if(newY <= groundY) {
    newY = groundY;
    velocity.y = 0;
    onGround = true;
  } else {
    onGround = false;
  }

  // Map bounds
  newX = Math.max(-53, Math.min(53, newX));
  newZ = Math.max(-53, Math.min(53, newZ));

  camera.position.set(newX, newY, newZ);

  // Footsteps
  if(dir.length() > 0 && onGround) {
    stepTimer += dt;
    if(stepTimer > 0.4) {
      playStep();
      stepTimer = 0;
    }
  }

  // Auto-fire
  if(shooting && weapons[currentWeapon].auto) {
    tryShoot();
  }

  // Gun bob & sway
  if(gunMesh) {
    const bobAmt = dir.length() > 0 && onGround ? 1 : 0;
    const bobX = Math.sin(time * 0.01) * 0.004 * bobAmt;
    const bobY = Math.abs(Math.cos(time * 0.01)) * 0.006 * bobAmt;
    
    if(currentWeapon === 'ak47') {
      gunMesh.position.x = 0.22 + bobX;
      gunMesh.position.y = -0.18 + bobY;
    } else if(currentWeapon === 'deagle') {
      gunMesh.position.x = 0.18 + bobX;
      gunMesh.position.y = -0.15 + bobY;
    } else if(currentWeapon === 'knife') {
      gunMesh.position.x = 0.2 + bobX;
      gunMesh.position.y = -0.1 + bobY;
    }
  }

  // Interpolate other players
  for(let pid in otherPlayerMeshes) {
    const pm = otherPlayerMeshes[pid];
    if(pm.targetPos) {
      pm.mesh.position.lerp(pm.targetPos, 0.15);
    }
    if(players[pid] && !players[pid].alive) {
      pm.mesh.visible = false;
    } else {
      pm.mesh.visible = true;
    }
  }

  // Send position
  if(ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({
      type:'move',
      x: camera.position.x,
      y: camera.position.y,
      z: camera.position.z,
      rx: pitch,
      ry: yaw
    }));
  }

  updateRadar();
  renderer.render(scene, camera);
}

// === SHOOTING ===
function tryShoot() {
  const w = weapons[currentWeapon];
  if(w.reloading || !isAlive) return;
  if(Date.now() - lastShot < w.fireRate) return;
  
  // Knife doesn't need ammo check
  if(!w.melee && w.clip <= 0) { reload(); return; }

  lastShot = Date.now();
  
  if(!w.melee) {
    w.clip--;
    updateAmmoUI();
    showMuzzleFlash();
  }
  
  playShoot(currentWeapon);

  // Recoil (less for knife)
  if(currentWeapon !== 'knife') {
    pitch += (Math.random() * 0.015 + 0.005);
    yaw += (Math.random() - 0.5) * 0.008;
  }
  camera.rotation.order = 'YXZ';
  camera.rotation.y = -yaw;
  camera.rotation.x = -pitch;

  // Gun kick animation
  if(gunMesh) {
    if(currentWeapon === 'knife') {
      // Knife swing
      gunMesh.rotation.x = 0.8;
      gunMesh.position.z = -0.15;
      setTimeout(() => {
        if(gunMesh && currentWeapon === 'knife') {
          gunMesh.rotation.x = 0.3;
          gunMesh.position.z = -0.25;
        }
      }, 150);
    } else {
      gunMesh.position.z += 0.05;
      gunMesh.rotation.x = -0.1;
      setTimeout(() => {
        if(gunMesh) {
          if(currentWeapon === 'ak47') gunMesh.position.z = -0.35;
          else if(currentWeapon === 'deagle') gunMesh.position.z = -0.28;
          gunMesh.rotation.x = 0;
        }
      }, 60);
    }
  }

  // Send shot
  const shootDir = new THREE.Vector3();
  camera.getWorldDirection(shootDir);
  
  if(!w.melee) {
    const spread = currentWeapon === 'ak47' ? 0.02 : 0.01;
    shootDir.x += (Math.random()-0.5) * spread;
    shootDir.y += (Math.random()-0.5) * spread;
    shootDir.z += (Math.random()-0.5) * spread;
    shootDir.normalize();
    showTracer(camera.position.x, camera.position.y, camera.position.z, shootDir.x, shootDir.y, shootDir.z);
  }

  if(ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({
      type:'shoot',
      x: camera.position.x,
      y: camera.position.y,
      z: camera.position.z,
      dx: shootDir.x, dy: shootDir.y, dz: shootDir.z,
      weapon: currentWeapon
    }));
  }

  // Bullet impact on walls (not for knife)
  if(!w.melee) {
    const raycaster = new THREE.Raycaster(camera.position.clone(), shootDir, 0, 100);
    const meshes = mapBoxes.map(b => b.mesh);
    const hits = raycaster.intersectObjects(meshes);
    if(hits.length > 0) {
      showBulletHole(hits[0].point, hits[0].face.normal);
    }
  }

  if(!w.melee && w.clip <= 0) {
    setTimeout(() => reload(), 300);
  }
}

function reload() {
  const w = weapons[currentWeapon];
  if(w.reloading || w.melee || w.total <= 0 || w.clip === w.maxClip) return;
  w.reloading = true;
  document.getElementById('ammoClip').textContent = '...';

  if(gunMesh) {
    gunMesh.rotation.z = 0.4;
  }

  setTimeout(() => {
    const needed = w.maxClip - w.clip;
    const available = Math.min(needed, w.total);
    w.clip += available;
    w.total -= available;
    w.reloading = false;
    updateAmmoUI();
    if(gunMesh) gunMesh.rotation.z = 0;
  }, w.reloadTime);
}

function resetAmmo() {
  weapons.ak47.clip = 30; weapons.ak47.total = 90;
  weapons.deagle.clip = 7; weapons.deagle.total = 35;
  updateAmmoUI();
}

function updateAmmoUI() {
  const w = weapons[currentWeapon];
  const ammoBar = document.getElementById('ammoBar');
  
  if(w.melee) {
    // Hide ammo for knife
    ammoBar.classList.add('hidden');
  } else {
    ammoBar.classList.remove('hidden');
    document.getElementById('ammoClip').textContent = w.clip;
    document.getElementById('ammoTotal').textContent = w.total;
  }
  document.getElementById('weaponName').textContent = w.name;
}

function updateHP() {
  const el = document.getElementById('hpNum');
  el.textContent = Math.max(0, hp);
  el.className = 'hp-num ' + (hp > 50 ? 'ok' : hp > 25 ? 'mid' : 'low');
}

// === VFX ===
function showMuzzleFlash() {
  const el = document.getElementById('muzzleFlash');
  el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), 50);
}

function showHitMarker() {
  const el = document.getElementById('hitMarker');
  el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), 200);
}

function showDamage() {
  const el = document.getElementById('dmgOverlay');
  el.classList.add('hit');
  setTimeout(() => el.classList.remove('hit'), 150);
}

function showTracer(x,y,z,dx,dy,dz) {
  const geo = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(x, y, z),
    new THREE.Vector3(x+dx*60, y+dy*60, z+dz*60)
  ]);
  const mat = new THREE.LineBasicMaterial({ color:0xffff66, transparent:true, opacity:0.5 });
  const line = new THREE.Line(geo, mat);
  scene.add(line);
  setTimeout(() => scene.remove(line), 80);
}

function showBulletHole(point, normal) {
  const geo = new THREE.CircleGeometry(0.04, 8);
  const mat = new THREE.MeshBasicMaterial({ color:0x111111, side:THREE.DoubleSide });
  const hole = new THREE.Mesh(geo, mat);
  hole.position.copy(point).add(new THREE.Vector3(normal.x*0.01, normal.y*0.01, normal.z*0.01));
  hole.lookAt(point.clone().add(normal));
  scene.add(hole);
  setTimeout(() => scene.remove(hole), 20000);
}

// === UI ===
function addKillFeed(killerId, victimId, weapon, headshot) {
  const feed = document.getElementById('killFeed');
  const entry = document.createElement('div');
  entry.className = 'kill-entry';
  const kName = players[killerId] ? players[killerId].name : 'Player';
  const vName = players[victimId] ? players[victimId].name : 'Player';
  const icon = weapon === 'knife' ? '🔪' : weapon === 'deagle' ? '🔫' : '💥';
  entry.innerHTML = `<span class="killer">${kName}</span> ${icon}${headshot?'★':''} <span class="victim">${vName}</span>`;
  feed.appendChild(entry);
  setTimeout(() => entry.remove(), 4000);
  if(feed.children.length > 5) feed.firstChild.remove();
}

function addChat(name, msg) {
  const msgs = document.getElementById('chatMsgs');
  const el = document.createElement('div');
  el.className = 'chat-msg';
  el.innerHTML = `<span class="cn">${name}:</span> ${msg}`;
  msgs.appendChild(el);
  setTimeout(() => el.remove(), 10000);
  if(msgs.children.length > 8) msgs.firstChild.remove();
}

function updateRadar() {
  const canvas = document.getElementById('radarCanvas');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0,0,140,140);

  const scale = 1.2;
  const cx = 70, cy = 70;

  ctx.strokeStyle = 'rgba(0,100,0,0.3)';
  ctx.lineWidth = 1;
  for(const box of mapBoxes) {
    const rx = (box.min.x + box.max.x)/2 - camera.position.x;
    const rz = (box.min.z + box.max.z)/2 - camera.position.z;
    const cos = Math.cos(yaw), sin = Math.sin(yaw);
    const sx = (rx * cos - rz * sin) * scale + cx;
    const sy = (rx * sin + rz * cos) * scale + cy;
    if(sx > 0 && sx < 140 && sy > 0 && sy < 140) {
      ctx.fillStyle = 'rgba(0,80,0,0.3)';
      ctx.fillRect(sx-1, sy-1, 2, 2);
    }
  }

  for(let pid in players) {
    if(pid == myId || !players[pid].alive) continue;
    const p = players[pid];
    const rx = p.x - camera.position.x;
    const rz = p.z - camera.position.z;
    const cos = Math.cos(yaw), sin = Math.sin(yaw);
    const sx = (rx * cos - rz * sin) * scale + cx;
    const sy = (rx * sin + rz * cos) * scale + cy;
    if(sx > 5 && sx < 135 && sy > 5 && sy < 135) {
      ctx.fillStyle = p.team === 'T' ? '#ff8800' : '#4488ff';
      ctx.beginPath();
      ctx.arc(sx, sy, 3, 0, Math.PI*2);
      ctx.fill();
    }
  }

  ctx.strokeStyle = '#0f0';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(cx, cy - 10);
  ctx.stroke();
}

function updateScoreboard() {
  const body = document.getElementById('sbBody');
  body.innerHTML = '';
  const sorted = Object.values(players).sort((a,b) => (b.kills||0) - (a.kills||0));
  for(const p of sorted) {
    const tr = document.createElement('tr');
    if(p.id == myId) tr.className = 'me';
    tr.innerHTML = `
      <td class="t-team ${p.team==='T'?'team-t':'team-ct'}">${p.team}</td>
      <td>${p.name||'Player'}</td>
      <td>${p.kills||0}</td>
      <td>${p.deaths||0}</td>
      <td>${p.alive?p.hp:'☠'}</td>
    `;
    body.appendChild(tr);
  }
}

// === INPUT ===
document.addEventListener('mousemove', (e) => {
  if(document.pointerLockElement && isAlive && !chatOpen) {
    const sens = parseFloat(document.getElementById('sensitivity').value) * 0.001 || 0.003;
    yaw += e.movementX * sens;
    pitch += e.movementY * sens;
    pitch = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, pitch));
    camera.rotation.order = 'YXZ';
    camera.rotation.y = -yaw;
    camera.rotation.x = -pitch;
  }
});

document.addEventListener('mousedown', (e) => {
  if(!document.pointerLockElement) {
    if(document.getElementById('menu').classList.contains('hidden')) {
      renderer.domElement.requestPointerLock();
    }
    return;
  }
  if(e.button === 0 && isAlive && !chatOpen) {
    shooting = true;
    tryShoot();
  }
});

document.addEventListener('mouseup', (e) => {
  if(e.button === 0) shooting = false;
});

document.addEventListener('keydown', (e) => {
  if(chatOpen) {
    if(e.key === 'Enter') {
      const input = document.getElementById('chatInput');
      if(input.value.trim() && ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type:'chat', msg: input.value }));
        addChat(document.getElementById('playerName').value, input.value);
      }
      input.value = '';
      input.classList.remove('show');
      chatOpen = false;
      renderer.domElement.requestPointerLock();
    }
    if(e.key === 'Escape') {
      document.getElementById('chatInput').classList.remove('show');
      chatOpen = false;
      renderer.domElement.requestPointerLock();
    }
    return;
  }

  switch(e.code) {
    case 'KeyW': moveState.forward = 1; break;
    case 'KeyS': moveState.back = 1; break;
    case 'KeyA': moveState.left = 1; break;
    case 'KeyD': moveState.right = 1; break;
    case 'Space': e.preventDefault(); moveState.jump = true; break;
    case 'KeyR': reload(); break;
    case 'Digit1':
      currentWeapon = 'ak47';
      createGunModel('ak47');
      updateAmmoUI();
      if(ws) ws.send(JSON.stringify({type:'switchWeapon',weapon:'ak47'}));
      break;
    case 'Digit2':
      currentWeapon = 'deagle';
      createGunModel('deagle');
      updateAmmoUI();
      if(ws) ws.send(JSON.stringify({type:'switchWeapon',weapon:'deagle'}));
      break;
    case 'Digit3':
      currentWeapon = 'knife';
      createGunModel('knife');
      updateAmmoUI();
      if(ws) ws.send(JSON.stringify({type:'switchWeapon',weapon:'knife'}));
      break;
    case 'Tab':
      e.preventDefault();
      updateScoreboard();
      document.getElementById('scoreboard').classList.add('show');
      break;
    case 'KeyT':
    case 'KeyY':
      if(document.pointerLockElement) {
        document.exitPointerLock();
        chatOpen = true;
        const input = document.getElementById('chatInput');
        input.classList.add('show');
        input.focus();
      }
      break;
    case 'Escape':
      if(document.pointerLockElement) {
        document.exitPointerLock();
      }
      break;
  }
});

document.addEventListener('keyup', (e) => {
  if(chatOpen) return;
  switch(e.code) {
    case 'KeyW': moveState.forward = 0; break;
    case 'KeyS': moveState.back = 0; break;
    case 'KeyA': moveState.left = 0; break;
    case 'KeyD': moveState.right = 0; break;
    case 'Space': moveState.jump = false; break;
    case 'Tab':
      document.getElementById('scoreboard').classList.remove('show');
      break;
  }
});

document.addEventListener('contextmenu', e => e.preventDefault());

// === MENU FUNCTIONS ===
function showSettings() {
  document.getElementById('settingsPanel').classList.add('show');
}
function hideSettings() {
  document.getElementById('settingsPanel').classList.remove('show');
}

function showControls() {
  alert(
    'MAXIS STRIKE - CONTROLS\n\n' +
    'WASD - Move\n' +
    'Mouse - Look\n' +
    'Left Click - Shoot/Stab\n' +
    'R - Reload\n' +
    'Space - Jump\n' +
    '1 - AK-47\n' +
    '2 - Desert Eagle\n' +
    '3 - Knife\n' +
    'T/Y - Chat\n' +
    'Tab - Scoreboard\n' +
    'Esc - Release mouse'
  );
}

function showAbout() {
  alert(
    'MAXIS STRIKE v2.0\n\n' +
    'A tactical multiplayer FPS\n' +
    'Built with Three.js & WebSocket\n\n' +
    'Start server: node server.js\n' +
    'Then click PLAY!'
  );
}
</script>
</body>
</html>
