<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MAXIS STRIKE</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Russo+One&family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');
  * { margin:0; padding:0; box-sizing:border-box; }
  body { background:#000; overflow:hidden; font-family:'Share Tech Mono',monospace; color:#fff; cursor:default; }
  canvas { display:block; }

  /* MENU */
  #menu {
    position:fixed; inset:0; z-index:100;
    background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #0a0a0a 100%);
    display:flex; flex-direction:column; align-items:center; justify-content:center;
  }
  #menu.hidden { display:none; }

  .menu-bg-effect {
    position:absolute; inset:0; overflow:hidden; pointer-events:none;
  }
  .menu-bg-effect::before {
    content:''; position:absolute; width:200%; height:200%; top:-50%; left:-50%;
    background: radial-gradient(circle at 30% 40%, rgba(255,100,0,0.05) 0%, transparent 50%),
                radial-gradient(circle at 70% 60%, rgba(0,150,255,0.05) 0%, transparent 50%);
    animation: bgRotate 20s linear infinite;
  }
  @keyframes bgRotate { to { transform:rotate(360deg); } }

  .menu-lines {
    position:absolute; inset:0; pointer-events:none; opacity:0.03;
    background: repeating-linear-gradient(0deg, transparent, transparent 2px, #fff 2px, #fff 3px);
  }

  .logo-container { text-align:center; margin-bottom:40px; position:relative; z-index:2; }
  .logo-sub { font-family:'Share Tech Mono',monospace; font-size:14px; color:#ff6600; letter-spacing:8px; text-transform:uppercase; margin-bottom:8px; }
  .logo-main {
    font-family:'Orbitron',sans-serif; font-size:72px; font-weight:900;
    background: linear-gradient(180deg, #fff 0%, #ff6600 50%, #cc3300 100%);
    -webkit-background-clip:text; -webkit-text-fill-color:transparent;
    text-shadow: none; filter: drop-shadow(0 0 30px rgba(255,100,0,0.3));
    letter-spacing:6px;
  }
  .logo-edition { font-family:'Share Tech Mono'; font-size:11px; color:#666; letter-spacing:12px; margin-top:5px; }

  .menu-buttons { display:flex; flex-direction:column; gap:4px; position:relative; z-index:2; min-width:320px; }
  .menu-btn {
    background: linear-gradient(90deg, rgba(255,102,0,0) 0%, rgba(255,102,0,0.08) 50%, rgba(255,102,0,0) 100%);
    border:none; color:#ccc; font-family:'Share Tech Mono',monospace; font-size:15px;
    padding:14px 40px; cursor:pointer; text-transform:uppercase; letter-spacing:4px;
    transition: all 0.2s; position:relative; text-align:left;
    border-left:2px solid transparent;
  }
  .menu-btn:hover {
    background: linear-gradient(90deg, rgba(255,102,0,0.15) 0%, rgba(255,102,0,0.05) 100%);
    color:#ff6600; border-left:2px solid #ff6600;
    text-shadow: 0 0 20px rgba(255,102,0,0.5);
  }
  .menu-btn:active { transform:scale(0.98); }

  .menu-footer {
    position:absolute; bottom:20px; font-size:11px; color:#333; letter-spacing:3px; z-index:2;
  }

  /* SETTINGS PANEL */
  #settingsPanel {
    position:fixed; inset:0; z-index:150; background:rgba(0,0,0,0.95);
    display:none; flex-direction:column; align-items:center; justify-content:center;
  }
  #settingsPanel.show { display:flex; }
  .settings-box {
    background: linear-gradient(180deg, #111 0%, #0a0a0a 100%);
    border:1px solid #222; padding:40px; min-width:400px;
  }
  .settings-box h2 { font-family:'Orbitron'; font-size:20px; color:#ff6600; margin-bottom:25px; letter-spacing:4px; }
  .setting-row { margin-bottom:18px; }
  .setting-row label { display:block; font-size:12px; color:#888; margin-bottom:6px; letter-spacing:2px; text-transform:uppercase; }
  .setting-row input[type=text], .setting-row input[type=number] {
    width:100%; background:#0a0a0a; border:1px solid #333; color:#fff; padding:10px;
    font-family:'Share Tech Mono'; font-size:14px; outline:none;
  }
  .setting-row input:focus { border-color:#ff6600; }
  .setting-row input[type=range] { width:100%; accent-color:#ff6600; }
  .settings-back {
    margin-top:20px; background:none; border:1px solid #333; color:#888; padding:10px 30px;
    cursor:pointer; font-family:'Share Tech Mono'; font-size:13px; letter-spacing:2px;
    transition:all 0.2s;
  }
  .settings-back:hover { border-color:#ff6600; color:#ff6600; }

  /* HUD */
  #hud { position:fixed; inset:0; z-index:50; pointer-events:none; }
  #hud.hidden { display:none; }

  .crosshair {
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
  }
  .crosshair div { position:absolute; background:#0f0; }
  .ch-top { width:2px; height:10px; left:-1px; top:-16px; }
  .ch-bot { width:2px; height:10px; left:-1px; top:6px; }
  .ch-left { width:10px; height:2px; left:-16px; top:-1px; }
  .ch-right { width:10px; height:2px; left:6px; top:-1px; }
  .ch-dot { width:2px; height:2px; left:-1px; top:-1px; background:rgba(0,255,0,0.5); }

  .hp-bar {
    position:absolute; bottom:20px; left:20px;
    display:flex; align-items:center; gap:12px;
  }
  .hp-icon { font-size:28px; }
  .hp-num { font-family:'Orbitron'; font-size:32px; font-weight:700; }
  .hp-num.low { color:#ff3333; }
  .hp-num.mid { color:#ffaa00; }
  .hp-num.ok { color:#fff; }

  .ammo-bar {
    position:absolute; bottom:20px; right:20px;
    display:flex; align-items:baseline; gap:6px;
  }
  .ammo-clip { font-family:'Orbitron'; font-size:32px; font-weight:700; }
  .ammo-sep { font-size:20px; color:#666; }
  .ammo-total { font-family:'Orbitron'; font-size:18px; color:#888; }

  .weapon-name {
    position:absolute; bottom:60px; right:20px;
    font-size:12px; color:#666; letter-spacing:3px; text-transform:uppercase;
  }

  .kill-feed {
    position:absolute; top:10px; right:10px;
    display:flex; flex-direction:column; gap:3px; align-items:flex-end;
  }
  .kill-entry {
    background:rgba(0,0,0,0.7); padding:4px 10px; font-size:12px;
    display:flex; gap:8px; align-items:center;
    animation: fadeKill 4s forwards;
    border-left:2px solid #ff6600;
  }
  @keyframes fadeKill { 0%,70%{opacity:1;} 100%{opacity:0;} }
  .kill-entry .killer { color:#ff6600; }
  .kill-entry .victim { color:#6cf; }
  .kill-entry .hs { color:#ff0; font-size:10px; }

  .hit-marker {
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); pointer-events:none; display:none;
  }
  .hit-marker.show { display:block; animation: hmPop 0.2s; }
  @keyframes hmPop { 0%{transform:translate(-50%,-50%) scale(1.5);opacity:1;} 100%{transform:translate(-50%,-50%) scale(1);opacity:0.8;} }
  .hm-line { position:absolute; background:#fff; }
  .hm-1 { width:12px; height:2px; transform:rotate(45deg); left:4px; top:-2px; }
  .hm-2 { width:12px; height:2px; transform:rotate(-45deg); left:4px; top:10px; }
  .hm-3 { width:12px; height:2px; transform:rotate(135deg); left:-6px; top:-2px; }
  .hm-4 { width:12px; height:2px; transform:rotate(-135deg); left:-6px; top:10px; }

  .dmg-overlay {
    position:fixed; inset:0; pointer-events:none; z-index:45;
    border:3px solid transparent; transition:border-color 0.1s;
  }
  .dmg-overlay.hit { border-color:rgba(255,0,0,0.6); }

  .death-screen {
    position:fixed; inset:0; z-index:60; background:rgba(100,0,0,0.5);
    display:none; align-items:center; justify-content:center; flex-direction:column;
  }
  .death-screen.show { display:flex; }
  .death-screen h2 { font-family:'Orbitron'; font-size:36px; color:#ff3333; }
  .death-screen p { color:#999; margin-top:10px; font-size:14px; }

  /* SCOREBOARD */
  #scoreboard {
    position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
    z-index:80; display:none; min-width:500px;
    background:rgba(0,0,0,0.92); border:1px solid #333;
  }
  #scoreboard.show { display:block; }
  .sb-header {
    background:#111; padding:12px 20px; font-family:'Orbitron'; font-size:14px;
    color:#ff6600; letter-spacing:4px; border-bottom:1px solid #333;
  }
  .sb-table { width:100%; border-collapse:collapse; }
  .sb-table th {
    text-align:left; padding:8px 15px; font-size:11px; color:#666;
    border-bottom:1px solid #222; letter-spacing:2px;
  }
  .sb-table td { padding:6px 15px; font-size:13px; border-bottom:1px solid #111; }
  .sb-table tr.me td { color:#ff6600; }
  .sb-table .t-team { width:30px; }
  .team-t { color:#f4a460; }
  .team-ct { color:#6ca6cd; }

  /* CHAT */
  #chatBox {
    position:fixed; bottom:80px; left:20px; z-index:70; width:350px;
  }
  .chat-msgs {
    max-height:150px; overflow:hidden; display:flex; flex-direction:column; gap:2px;
    margin-bottom:5px;
  }
  .chat-msg {
    font-size:12px; background:rgba(0,0,0,0.5); padding:3px 8px;
    animation: fadeMsg 10s forwards;
  }
  @keyframes fadeMsg { 0%,80%{opacity:1;} 100%{opacity:0;} }
  .chat-msg .cn { color:#ff6600; }
  .chat-input {
    display:none; background:rgba(0,0,0,0.8); border:1px solid #333;
    color:#fff; padding:6px 10px; width:100%; font-family:'Share Tech Mono';
    font-size:13px; outline:none;
  }
  .chat-input.show { display:block; pointer-events:auto; }

  /* RADAR */
  .radar {
    position:absolute; top:15px; left:15px; width:140px; height:140px;
    background:rgba(0,20,0,0.7); border:1px solid #1a3a1a; border-radius:4px;
    overflow:hidden;
  }
  .radar-center { position:absolute; top:50%; left:50%; width:4px; height:4px; background:#0f0; border-radius:50%; transform:translate(-50%,-50%); z-index:2; }
  .radar canvas { position:absolute; inset:0; }

  .conn-status {
    position:absolute; top:15px; left:50%; transform:translateX(-50%);
    font-size:11px; letter-spacing:2px; padding:4px 12px;
    background:rgba(0,0,0,0.6);
  }
  .conn-status.ok { color:#0f0; }
  .conn-status.err { color:#f33; }

  /* GUN FLASH */
  .muzzle-flash {
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    width:60px; height:60px; border-radius:50%;
    background:radial-gradient(circle, rgba(255,200,50,0.8), transparent);
    display:none; pointer-events:none;
  }
  .muzzle-flash.show { display:block; animation: flash 0.05s; }
  @keyframes flash { 0%{opacity:1;transform:translate(-50%,-50%) scale(1.5);} 100%{opacity:0;} }
</style>
</head>
<body>

<!-- MAIN MENU -->
<div id="menu">
  <div class="menu-bg-effect"></div>
  <div class="menu-lines"></div>
  <div class="logo-container">
    <div class="logo-sub">★ TACTICAL SHOOTER ★</div>
    <div class="logo-main">MAXIS STRIKE</div>
    <div class="logo-edition">MULTIPLAYER EDITION v1.0</div>
  </div>
  <div class="menu-buttons">
    <button class="menu-btn" onclick="connectAndPlay()">► PLAY</button>
    <button class="menu-btn" onclick="showSettings()">⚙ SETTINGS</button>
    <button class="menu-btn" onclick="showControls()">⌨ CONTROLS</button>
    <button class="menu-btn" onclick="showAbout()">ℹ ABOUT</button>
  </div>
  <div class="menu-footer">© 2024 MAXIS STRIKE — ALL RIGHTS RESERVED</div>
</div>

<!-- SETTINGS -->
<div id="settingsPanel">
  <div class="settings-box">
    <h2>⚙ SETTINGS</h2>
    <div class="setting-row">
      <label>Player Name</label>
      <input type="text" id="playerName" value="Player" maxlength="16">
    </div>
    <div class="setting-row">
      <label>Mouse Sensitivity: <span id="sensVal">3.0</span></label>
      <input type="range" id="sensitivity" min="0.5" max="10" step="0.5" value="3" oninput="document.getElementById('sensVal').textContent=this.value">
    </div>
    <div class="setting-row">
      <label>FOV: <span id="fovVal">75</span></label>
      <input type="range" id="fovSetting" min="60" max="110" step="5" value="75" oninput="document.getElementById('fovVal').textContent=this.value">
    </div>
    <div class="setting-row">
      <label>Server Address (auto-detected)</label>
      <input type="text" id="serverAddr" value="" readonly style="opacity:0.6">
    </div>
    <div class="setting-row">
      <label>Volume: <span id="volVal">50</span>%</label>
      <input type="range" id="volume" min="0" max="100" step="5" value="50" oninput="document.getElementById('volVal').textContent=this.value">
    </div>
    <button class="settings-back" onclick="hideSettings()">← BACK</button>
  </div>
</div>

<!-- HUD -->
<div id="hud" class="hidden">
  <div class="crosshair" id="crosshair">
    <div class="ch-top"></div>
    <div class="ch-bot"></div>
    <div class="ch-left"></div>
    <div class="ch-right"></div>
    <div class="ch-dot"></div>
  </div>

  <div class="hp-bar">
    <span class="hp-icon">✚</span>
    <span class="hp-num ok" id="hpNum">100</span>
  </div>

  <div class="ammo-bar">
    <span class="ammo-clip" id="ammoClip">30</span>
    <span class="ammo-sep">/</span>
    <span class="ammo-total" id="ammoTotal">90</span>
  </div>
  <div class="weapon-name" id="weaponName">AK-47</div>

  <div class="kill-feed" id="killFeed"></div>

  <div class="hit-marker" id="hitMarker">
    <div class="hm-line hm-1"></div>
    <div class="hm-line hm-2"></div>
    <div class="hm-line hm-3"></div>
    <div class="hm-line hm-4"></div>
  </div>

  <div class="muzzle-flash" id="muzzleFlash"></div>

  <div class="radar">
    <canvas id="radarCanvas" width="140" height="140"></canvas>
    <div class="radar-center"></div>
  </div>

  <div class="conn-status ok" id="connStatus">CONNECTED</div>
</div>

<div class="dmg-overlay" id="dmgOverlay"></div>
<div class="death-screen" id="deathScreen">
  <h2>YOU DIED</h2>
  <p>Respawning in 3 seconds...</p>
</div>
<div id="scoreboard">
  <div class="sb-header">SCOREBOARD</div>
  <table class="sb-table">
    <thead><tr><th class="t-team"></th><th>NAME</th><th>K</th><th>D</th><th>HP</th></tr></thead>
    <tbody id="sbBody"></tbody>
  </table>
</div>
<div id="chatBox">
  <div class="chat-msgs" id="chatMsgs"></div>
  <input class="chat-input" id="chatInput" placeholder="Type message..." maxlength="100">
</div>

<!-- THREE.JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ═══════════════════════════════════════════
// MAXIS STRIKE - Full 3D FPS Client
// ═══════════════════════════════════════════

// === AUDIO ENGINE ===
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx;
function ensureAudio() { if(!audioCtx) audioCtx = new AudioCtx(); }

function playShoot() {
  ensureAudio();
  const vol = parseInt(document.getElementById('volume').value) / 100;
  const g = audioCtx.createGain(); g.gain.value = 0.15 * vol; g.connect(audioCtx.destination);
  // noise burst
  const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.08, audioCtx.sampleRate);
  const d = buf.getChannelData(0);
  for(let i=0;i<d.length;i++) d[i] = (Math.random()*2-1) * Math.pow(1 - i/d.length, 3);
  const s = audioCtx.createBufferSource(); s.buffer = buf; s.connect(g); s.start();
  // low thump
  const osc = audioCtx.createOscillator(); osc.frequency.value = 80;
  const g2 = audioCtx.createGain(); g2.gain.value = 0.2 * vol; g2.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime+0.1);
  osc.connect(g2); g2.connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime+0.1);
}

function playHit() {
  ensureAudio();
  const vol = parseInt(document.getElementById('volume').value) / 100;
  const osc = audioCtx.createOscillator(); osc.type='sine'; osc.frequency.value=800;
  const g = audioCtx.createGain(); g.gain.value=0.1*vol; g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+0.1);
  osc.connect(g); g.connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime+0.1);
}

function playDeath() {
  ensureAudio();
  const vol = parseInt(document.getElementById('volume').value) / 100;
  const osc = audioCtx.createOscillator(); osc.type='sawtooth'; osc.frequency.value=200;
  osc.frequency.exponentialRampToValueAtTime(50,audioCtx.currentTime+0.5);
  const g = audioCtx.createGain(); g.gain.value=0.15*vol; g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+0.5);
  osc.connect(g); g.connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime+0.5);
}

function playStep() {
  ensureAudio();
  const vol = parseInt(document.getElementById('volume').value) / 100;
  const buf = audioCtx.createBuffer(1, audioCtx.sampleRate*0.05, audioCtx.sampleRate);
  const d = buf.getChannelData(0);
  for(let i=0;i<d.length;i++) d[i] = (Math.random()*2-1)*Math.pow(1-i/d.length,5)*0.3;
  const s = audioCtx.createBufferSource(); s.buffer=buf;
  const g = audioCtx.createGain(); g.gain.value=0.05*vol;
  const f = audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=500;
  s.connect(f); f.connect(g); g.connect(audioCtx.destination); s.start();
}

// === GAME STATE ===
let ws = null;
let myId = null;
let myPlayer = null;
let players = {};
let scene, camera, renderer;
let moveState = { forward:0, back:0, left:0, right:0, jump:false };
let velocity = new THREE.Vector3();
let yaw = 0, pitch = 0;
let onGround = true;
let weapons = {
  ak47: { name:'AK-47', clip:30, maxClip:30, total:90, fireRate:100, reloading:false, reloadTime:2500, damage:27, auto:true },
  deagle: { name:'Desert Eagle', clip:7, maxClip:7, total:35, fireRate:300, reloading:false, reloadTime:1800, damage:45, auto:false },
  knife: { name:'Knife', clip:1, maxClip:1, total:1, fireRate:500, reloading:false, reloadTime:0, damage:50, auto:false }
};
let currentWeapon = 'ak47';
let lastShot = 0;
let canShoot = true;
let isAlive = true;
let hp = 100;
let otherPlayerMeshes = {};
let gunMesh = null;
let shooting = false;
let stepTimer = 0;
let chatOpen = false;

// Map elements for collision
let mapBoxes = [];

// === INIT 3D ===
function init3D() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);
  scene.fog = new THREE.Fog(0x87CEEB, 80, 200);

  const fov = parseInt(document.getElementById('fovSetting').value) || 75;
  camera = new THREE.PerspectiveCamera(fov, window.innerWidth/window.innerHeight, 0.1, 500);
  camera.position.set(0, 1.5, 0);

  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.prepend(renderer.domElement);

  // Lights
  const amb = new THREE.AmbientLight(0x666677, 0.6);
  scene.add(amb);

  const sun = new THREE.DirectionalLight(0xfff5e0, 1.0);
  sun.position.set(30, 50, 20);
  sun.castShadow = true;
  sun.shadow.mapSize.width = 2048;
  sun.shadow.mapSize.height = 2048;
  sun.shadow.camera.near = 0.5;
  sun.shadow.camera.far = 200;
  sun.shadow.camera.left = -60;
  sun.shadow.camera.right = 60;
  sun.shadow.camera.top = 60;
  sun.shadow.camera.bottom = -60;
  scene.add(sun);

  const hemi = new THREE.HemisphereLight(0x87CEEB, 0x5a4a3a, 0.3);
  scene.add(hemi);

  buildMap();
  createGunModel();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

// === BUILD MAP ===
function buildMap() {
  // Ground
  const groundGeo = new THREE.PlaneGeometry(120, 120);
  const groundMat = new THREE.MeshLambertMaterial({ color: 0x8B7355 });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Grid on ground
  const gridGeo = new THREE.PlaneGeometry(120, 120);
  const gridMat = new THREE.MeshBasicMaterial({
    color: 0x6B5B45, wireframe:false, transparent:true, opacity:0.3
  });

  // Textures via canvas
  const tc = document.createElement('canvas'); tc.width=512; tc.height=512;
  const tctx = tc.getContext('2d');
  tctx.fillStyle='#8B7355'; tctx.fillRect(0,0,512,512);
  // Add some noise
  for(let i=0;i<5000;i++){
    tctx.fillStyle=`rgba(${100+Math.random()*60},${80+Math.random()*50},${50+Math.random()*40},0.3)`;
    tctx.fillRect(Math.random()*512, Math.random()*512, 2+Math.random()*4, 2+Math.random()*4);
  }
  const groundTex = new THREE.CanvasTexture(tc);
  groundTex.wrapS = groundTex.wrapT = THREE.RepeatWrapping;
  groundTex.repeat.set(15,15);
  ground.material.map = groundTex;
  ground.material.needsUpdate = true;

  // Wall texture
  function wallTex() {
    const c = document.createElement('canvas'); c.width=128; c.height=128;
    const ctx = c.getContext('2d');
    ctx.fillStyle='#9B8B6B'; ctx.fillRect(0,0,128,128);
    ctx.strokeStyle='#7B6B4B'; ctx.lineWidth=2;
    for(let y=0;y<128;y+=16){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(128,y);ctx.stroke();}
    for(let x=0;x<128;x+=32){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,128);ctx.stroke();}
    const t = new THREE.CanvasTexture(c);
    t.wrapS=t.wrapT=THREE.RepeatWrapping;
    return t;
  }

  function crateTex() {
    const c = document.createElement('canvas'); c.width=128; c.height=128;
    const ctx = c.getContext('2d');
    ctx.fillStyle='#8B6914'; ctx.fillRect(0,0,128,128);
    ctx.strokeStyle='#654321'; ctx.lineWidth=3;
    ctx.strokeRect(5,5,118,118);
    ctx.beginPath(); ctx.moveTo(5,5); ctx.lineTo(123,123); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(123,5); ctx.lineTo(5,123); ctx.stroke();
    return new THREE.CanvasTexture(c);
  }

  const wt = wallTex();
  const ct = crateTex();

  function addWall(x,y,z,w,h,d,color) {
    const geo = new THREE.BoxGeometry(w,h,d);
    const mat = new THREE.MeshLambertMaterial({ color: color||0x9B8B6B, map: wt.clone() });
    mat.map.repeat.set(w/4, h/4);
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x,y,z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    mapBoxes.push({ mesh, min:{x:x-w/2,y:y-h/2,z:z-d/2}, max:{x:x+w/2,y:y+h/2,z:z+d/2} });
    return mesh;
  }

  function addCrate(x,z,s) {
    s = s||2;
    const geo = new THREE.BoxGeometry(s,s,s);
    const mat = new THREE.MeshLambertMaterial({ map: ct.clone() });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x, s/2, z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    mapBoxes.push({ mesh, min:{x:x-s/2,y:0,z:z-s/2}, max:{x:x+s/2,y:s,z:z+s/2} });
  }

  // Perimeter walls
  addWall(0, 3, -55, 120, 6, 2, 0x8B7B5B);
  addWall(0, 3, 55, 120, 6, 2, 0x8B7B5B);
  addWall(-55, 3, 0, 2, 6, 120, 0x8B7B5B);
  addWall(55, 3, 0, 2, 6, 120, 0x8B7B5B);

  // Central building
  addWall(0, 2.5, -8, 12, 5, 1, 0x9B8B6B);
  addWall(0, 2.5, 8, 12, 5, 1, 0x9B8B6B);
  addWall(-6, 2.5, 0, 1, 5, 16, 0x9B8B6B);
  addWall(6, 2.5, 0, 1, 5, 16, 0x9B8B6B);

  // A site platform
  addWall(-25, 0.5, -25, 14, 1, 14, 0x7B6B4B);
  addWall(-25, 2.5, -32, 14, 5, 1, 0x9B8B6B);
  addWall(-32, 2.5, -25, 1, 5, 14, 0x9B8B6B);

  // B site platform
  addWall(25, 0.5, 25, 14, 1, 14, 0x7B6B4B);
  addWall(25, 2.5, 32, 14, 5, 1, 0x9B8B6B);
  addWall(32, 2.5, 25, 1, 5, 14, 0x9B8B6B);

  // Corridors
  addWall(-15, 2, -15, 8, 4, 1, 0xAA9A7A);
  addWall(-15, 2, -10, 1, 4, 10, 0xAA9A7A);
  addWall(15, 2, 15, 8, 4, 1, 0xAA9A7A);
  addWall(15, 2, 10, 1, 4, 10, 0xAA9A7A);

  // Crates scattered
  addCrate(-10, -3, 2);
  addCrate(-8, -3, 2);
  addCrate(-9, -1, 2);
  addCrate(10, 3, 2);
  addCrate(12, 3, 2);
  addCrate(-30, -15, 2.5);
  addCrate(-30, -12, 2.5);
  addCrate(30, 15, 2.5);
  addCrate(30, 12, 2.5);
  addCrate(0, -20, 1.5);
  addCrate(0, 20, 1.5);
  addCrate(-20, 0, 2);
  addCrate(20, 0, 2);
  addCrate(-40, -40, 3);
  addCrate(40, 40, 3);
  addCrate(-35, 30, 2);
  addCrate(35, -30, 2);
  addCrate(5, -35, 2);
  addCrate(-5, 35, 2);

  // Ramp
  const rampGeo = new THREE.BoxGeometry(4, 0.3, 8);
  const rampMat = new THREE.MeshLambertMaterial({ color:0x7B6B4B });
  const ramp = new THREE.Mesh(rampGeo, rampMat);
  ramp.position.set(-25, 0.5, -18);
  ramp.rotation.x = 0.15;
  ramp.castShadow = true;
  scene.add(ramp);

  // Cover walls - mid
  addWall(-3, 1.5, -20, 6, 3, 0.5, 0xAA9A7A);
  addWall(3, 1.5, 20, 6, 3, 0.5, 0xAA9A7A);
  addWall(-20, 1.5, -3, 0.5, 3, 6, 0xAA9A7A);
  addWall(20, 1.5, 3, 0.5, 3, 6, 0xAA9A7A);

  // Barrel-like cylinders
  function addBarrel(x,z) {
    const geo = new THREE.CylinderGeometry(0.5, 0.5, 1.2, 8);
    const mat = new THREE.MeshLambertMaterial({ color:0x444444 });
    const m = new THREE.Mesh(geo, mat);
    m.position.set(x, 0.6, z);
    m.castShadow = true;
    scene.add(m);
    mapBoxes.push({ mesh:m, min:{x:x-0.5,y:0,z:z-0.5}, max:{x:x+0.5,y:1.2,z:z+0.5} });
  }
  addBarrel(-12, 8); addBarrel(-11, 8.5); addBarrel(12, -8); addBarrel(11, -8.5);
  addBarrel(-38, 0); addBarrel(38, 0);

  // Skybox feel - distant objects
  for(let i=0; i<20; i++) {
    const bGeo = new THREE.BoxGeometry(5+Math.random()*10, 10+Math.random()*20, 5+Math.random()*10);
    const bMat = new THREE.MeshLambertMaterial({ color: new THREE.Color().setHSL(0.08, 0.2, 0.3+Math.random()*0.2) });
    const b = new THREE.Mesh(bGeo, bMat);
    const angle = (i/20)*Math.PI*2;
    b.position.set(Math.cos(angle)*90, bGeo.parameters.height/2, Math.sin(angle)*90);
    scene.add(b);
  }
}

// === GUN MODEL ===
function createGunModel() {
  gunMesh = new THREE.Group();

  // Gun body
  const body = new THREE.Mesh(
    new THREE.BoxGeometry(0.06, 0.08, 0.5),
    new THREE.MeshLambertMaterial({ color:0x2a2a2a })
  );
  gunMesh.add(body);

  // Barrel
  const barrel = new THREE.Mesh(
    new THREE.BoxGeometry(0.03, 0.03, 0.35),
    new THREE.MeshLambertMaterial({ color:0x1a1a1a })
  );
  barrel.position.set(0, 0.02, -0.4);
  gunMesh.add(barrel);

  // Magazine
  const mag = new THREE.Mesh(
    new THREE.BoxGeometry(0.04, 0.15, 0.08),
    new THREE.MeshLambertMaterial({ color:0x333333 })
  );
  mag.position.set(0, -0.1, -0.05);
  mag.rotation.x = 0.15;
  gunMesh.add(mag);

  // Stock
  const stock = new THREE.Mesh(
    new THREE.BoxGeometry(0.05, 0.06, 0.2),
    new THREE.MeshLambertMaterial({ color:0x5a3a1a })
  );
  stock.position.set(0, 0, 0.3);
  gunMesh.add(stock);

  // Grip
  const grip = new THREE.Mesh(
    new THREE.BoxGeometry(0.04, 0.1, 0.04),
    new THREE.MeshLambertMaterial({ color:0x3a3a3a })
  );
  grip.position.set(0, -0.08, 0.1);
  grip.rotation.x = -0.3;
  gunMesh.add(grip);

  gunMesh.position.set(0.25, -0.2, -0.4);
  camera.add(gunMesh);
  scene.add(camera);
}

// === MULTIPLAYER ===
function getWebSocketURL() {
  // Auto-detect WebSocket URL based on current page location
  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  const host = window.location.host;
  // If running locally (file://), use localhost
  if (window.location.protocol === 'file:') {
    return 'ws://localhost:3000';
  }
  return `${protocol}//${host}`;
}

// Set server address on load
document.addEventListener('DOMContentLoaded', () => {
  document.getElementById('serverAddr').value = getWebSocketURL();
});

function connectAndPlay() {
  const addr = getWebSocketURL();
  const name = document.getElementById('playerName').value || 'Player';

  document.getElementById('connStatus').className = 'conn-status err';
  document.getElementById('connStatus').textContent = 'CONNECTING...';

  try {
    ws = new WebSocket(addr);
  } catch(e) {
    alert('Cannot connect to server!\nMake sure server.js is running:\nnpm install ws && node server.js');
    return;
  }

  ws.onopen = () => {
    console.log('Connected to MAXIS STRIKE server');
    document.getElementById('connStatus').className = 'conn-status ok';
    document.getElementById('connStatus').textContent = 'CONNECTED';
    ws.send(JSON.stringify({ type:'setName', name }));
    startGame();
  };

  ws.onmessage = (e) => {
    const data = JSON.parse(e.data);
    handleServerMessage(data);
  };

  ws.onclose = () => {
    document.getElementById('connStatus').className = 'conn-status err';
    document.getElementById('connStatus').textContent = 'DISCONNECTED';
  };

  ws.onerror = () => {
    alert('Connection failed!\nStart the server first:\nnpm install ws && node server.js');
    document.getElementById('connStatus').className = 'conn-status err';
    document.getElementById('connStatus').textContent = 'ERROR';
  };
}

function handleServerMessage(data) {
  switch(data.type) {
    case 'init':
      myId = data.id;
      myPlayer = data.player;
      players = data.players;
      camera.position.set(data.player.x, data.player.y, data.player.z);
      // Create meshes for existing players
      for(let pid in players) {
        if(pid != myId) createPlayerMesh(pid, players[pid]);
      }
      break;

    case 'playerJoin':
      players[data.player.id] = data.player;
      createPlayerMesh(data.player.id, data.player);
      addChat('SERVER', data.player.name + ' joined the game');
      break;

    case 'playerLeave':
      delete players[data.id];
      removePlayerMesh(data.id);
      addChat('SERVER', 'Player disconnected');
      break;

    case 'playerMove':
      if(data.id != myId && otherPlayerMeshes[data.id]) {
        const pm = otherPlayerMeshes[data.id];
        pm.targetPos = new THREE.Vector3(data.x, data.y, data.z);
        pm.mesh.rotation.y = -data.ry;
      }
      if(players[data.id]) {
        players[data.id].x = data.x;
        players[data.id].y = data.y;
        players[data.id].z = data.z;
      }
      break;

    case 'playerShoot':
      if(data.id != myId) {
        playShoot();
        // Show tracer
        showTracer(data.x, data.y, data.z, data.dx, data.dy, data.dz);
      }
      break;

    case 'hit':
      hp = data.hp;
      updateHP();
      showDamage();
      playHit();
      break;

    case 'hitConfirm':
      showHitMarker();
      playHit();
      break;

    case 'kill':
      addKillFeed(data.killerId, data.victimId, data.weapon, data.headshot);
      if(data.victimId === myId) {
        isAlive = false;
        document.getElementById('deathScreen').classList.add('show');
        playDeath();
      }
      if(players[data.killerId]) players[data.killerId].kills = (players[data.killerId].kills||0)+1;
      if(players[data.victimId]) players[data.victimId].deaths = (players[data.victimId].deaths||0)+1;
      break;

    case 'respawn':
      if(data.id === myId) {
        isAlive = true;
        hp = 100;
        updateHP();
        camera.position.set(data.x, data.y, data.z);
        document.getElementById('deathScreen').classList.remove('show');
        resetAmmo();
      }
      if(players[data.id]) {
        players[data.id].alive = true;
        players[data.id].hp = 100;
        players[data.id].x = data.x;
        players[data.id].y = data.y;
        players[data.id].z = data.z;
      }
      break;

    case 'state':
      // Periodic state sync
      for(let pid in data.players) {
        players[pid] = data.players[pid];
        if(pid != myId && !otherPlayerMeshes[pid]) {
          createPlayerMesh(pid, data.players[pid]);
        }
      }
      // Remove stale
      for(let pid in otherPlayerMeshes) {
        if(!data.players[pid]) removePlayerMesh(pid);
      }
      break;

    case 'chat':
      addChat(data.name, data.msg);
      break;

    case 'nameChange':
      if(players[data.id]) players[data.id].name = data.name;
      break;

    case 'weaponSwitch':
      // Could update other player's visible weapon
      break;
  }
}

function createPlayerMesh(id, pdata) {
  if(id == myId || otherPlayerMeshes[id]) return;

  const group = new THREE.Group();

  const isT = pdata.team === 'T';
  const bodyColor = isT ? 0xc4782a : 0x2a5a8a;
  const headColor = isT ? 0xdaa06d : 0xdaa06d;

  // Body
  const bodyGeo = new THREE.BoxGeometry(0.7, 1.0, 0.5);
  const bodyMat = new THREE.MeshLambertMaterial({ color: bodyColor });
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.y = 0.5;
  body.castShadow = true;
  group.add(body);

  // Head
  const headGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
  const headMat = new THREE.MeshLambertMaterial({ color: headColor });
  const head = new THREE.Mesh(headGeo, headMat);
  head.position.y = 1.3;
  head.castShadow = true;
  group.add(head);

  // Legs
  for(let side of [-1,1]) {
    const legGeo = new THREE.BoxGeometry(0.25, 0.6, 0.3);
    const legMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
    const leg = new THREE.Mesh(legGeo, legMat);
    leg.position.set(side*0.2, -0.1, 0);
    group.add(leg);
  }

  // Arms
  for(let side of [-1,1]) {
    const armGeo = new THREE.BoxGeometry(0.2, 0.7, 0.2);
    const armMat = new THREE.MeshLambertMaterial({ color: bodyColor });
    const arm = new THREE.Mesh(armGeo, armMat);
    arm.position.set(side*0.45, 0.5, -0.1);
    group.add(arm);
  }

  // Gun in hands
  const gunGeo = new THREE.BoxGeometry(0.06, 0.06, 0.5);
  const gunMat2 = new THREE.MeshLambertMaterial({ color:0x1a1a1a });
  const gun = new THREE.Mesh(gunGeo, gunMat2);
  gun.position.set(0.3, 0.55, -0.35);
  group.add(gun);

  // Name label
  const nameCanvas = document.createElement('canvas');
  nameCanvas.width = 256; nameCanvas.height = 64;
  const nctx = nameCanvas.getContext('2d');
  nctx.fillStyle = isT ? '#ff8800' : '#4488ff';
  nctx.font = 'bold 28px monospace';
  nctx.textAlign = 'center';
  nctx.fillText(pdata.name || 'Player', 128, 35);
  const nameTex = new THREE.CanvasTexture(nameCanvas);
  const nameSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: nameTex, transparent:true }));
  nameSprite.position.y = 1.8;
  nameSprite.scale.set(2, 0.5, 1);
  group.add(nameSprite);

  group.position.set(pdata.x || 0, 0, pdata.z || 0);
  scene.add(group);

  otherPlayerMeshes[id] = { mesh: group, targetPos: new THREE.Vector3(pdata.x||0, 0, pdata.z||0) };
}

function removePlayerMesh(id) {
  if(otherPlayerMeshes[id]) {
    scene.remove(otherPlayerMeshes[id].mesh);
    delete otherPlayerMeshes[id];
  }
}

// === GAME LOOP ===
let lastTime = 0;
function startGame() {
  if(!scene) init3D();
  document.getElementById('menu').classList.add('hidden');
  document.getElementById('hud').classList.remove('hidden');
  renderer.domElement.requestPointerLock();
  requestAnimationFrame(gameLoop);
}

function gameLoop(time) {
  requestAnimationFrame(gameLoop);
  const dt = Math.min((time - lastTime) / 1000, 0.1);
  lastTime = time;

  if(!isAlive) {
    renderer.render(scene, camera);
    return;
  }

  // Movement
  const sens = parseFloat(document.getElementById('sensitivity').value) || 3;
  const speed = 12;
  const dir = new THREE.Vector3();
  const front = new THREE.Vector3();
  camera.getWorldDirection(front);
  front.y = 0; front.normalize();
  const right = new THREE.Vector3().crossVectors(front, new THREE.Vector3(0,1,0)).normalize();

  if(moveState.forward) dir.add(front);
  if(moveState.back) dir.sub(front);
  if(moveState.right) dir.add(right);
  if(moveState.left) dir.sub(right);
  if(dir.length() > 0) dir.normalize();

  velocity.x = dir.x * speed;
  velocity.z = dir.z * speed;

  // Gravity & Jump
  if(!onGround) {
    velocity.y -= 25 * dt;
  }
  if(moveState.jump && onGround) {
    velocity.y = 8;
    onGround = false;
  }

  // Apply velocity
  let newX = camera.position.x + velocity.x * dt;
  let newY = camera.position.y + velocity.y * dt;
  let newZ = camera.position.z + velocity.z * dt;

  // Collision detection
  const playerRadius = 0.4;
  const playerHeight = 1.5;

  for(const box of mapBoxes) {
    // Check X
    if(newX + playerRadius > box.min.x && newX - playerRadius < box.max.x &&
       camera.position.z + playerRadius > box.min.z && camera.position.z - playerRadius < box.max.z &&
       newY > box.min.y && newY - playerHeight < box.max.y) {
      if(camera.position.x <= box.min.x - playerRadius) newX = box.min.x - playerRadius;
      else if(camera.position.x >= box.max.x + playerRadius) newX = box.max.x + playerRadius;
    }
    // Check Z
    if(newX + playerRadius > box.min.x && newX - playerRadius < box.max.x &&
       newZ + playerRadius > box.min.z && newZ - playerRadius < box.max.z &&
       newY > box.min.y && newY - playerHeight < box.max.y) {
      if(camera.position.z <= box.min.z - playerRadius) newZ = box.min.z - playerRadius;
      else if(camera.position.z >= box.max.z + playerRadius) newZ = box.max.z + playerRadius;
    }
  }

  // Ground collision
  let groundY = 1.5; // default ground
  for(const box of mapBoxes) {
    if(newX + playerRadius > box.min.x && newX - playerRadius < box.max.x &&
       newZ + playerRadius > box.min.z && newZ - playerRadius < box.max.z) {
      if(box.max.y < newY && box.max.y + playerHeight > newY) {
        groundY = Math.max(groundY, box.max.y + playerHeight);
      }
    }
  }

  if(newY <= groundY) {
    newY = groundY;
    velocity.y = 0;
    onGround = true;
  } else {
    onGround = false;
  }

  // Map bounds
  newX = Math.max(-53, Math.min(53, newX));
  newZ = Math.max(-53, Math.min(53, newZ));

  camera.position.set(newX, newY, newZ);

  // Footsteps
  if(dir.length() > 0 && onGround) {
    stepTimer += dt;
    if(stepTimer > 0.4) {
      playStep();
      stepTimer = 0;
    }
  }

  // Auto-fire
  if(shooting && weapons[currentWeapon].auto) {
    tryShoot();
  }

  // Gun bob
  if(gunMesh) {
    const bobAmt = dir.length() > 0 && onGround ? 1 : 0;
    const bobX = Math.sin(time * 0.008) * 0.003 * bobAmt;
    const bobY = Math.abs(Math.cos(time * 0.008)) * 0.005 * bobAmt;
    gunMesh.position.x = 0.25 + bobX;
    gunMesh.position.y = -0.2 + bobY;
  }

  // Interpolate other players
  for(let pid in otherPlayerMeshes) {
    const pm = otherPlayerMeshes[pid];
    if(pm.targetPos) {
      pm.mesh.position.lerp(pm.targetPos, 0.15);
    }
    // Hide if dead
    if(players[pid] && !players[pid].alive) {
      pm.mesh.visible = false;
    } else {
      pm.mesh.visible = true;
    }
  }

  // Send position
  if(ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({
      type:'move',
      x: camera.position.x,
      y: camera.position.y,
      z: camera.position.z,
      rx: pitch,
      ry: yaw
    }));
  }

  // Radar
  updateRadar();

  // Render
  renderer.render(scene, camera);
}

// === SHOOTING ===
function tryShoot() {
  const w = weapons[currentWeapon];
  if(w.reloading || !isAlive) return;
  if(Date.now() - lastShot < w.fireRate) return;
  if(w.clip <= 0) { reload(); return; }

  lastShot = Date.now();
  w.clip--;
  updateAmmoUI();
  playShoot();
  showMuzzleFlash();

  // Recoil
  pitch += (Math.random() * 0.015 + 0.005);
  yaw += (Math.random() - 0.5) * 0.008;
  camera.rotation.order = 'YXZ';
  camera.rotation.y = -yaw;
  camera.rotation.x = -pitch;

  // Gun kick animation
  if(gunMesh) {
    gunMesh.position.z = -0.35;
    gunMesh.rotation.x = -0.1;
    setTimeout(() => {
      if(gunMesh) { gunMesh.position.z = -0.4; gunMesh.rotation.x = 0; }
    }, 60);
  }

  // Send shot
  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);
  // Add spread
  const spread = currentWeapon === 'ak47' ? 0.02 : currentWeapon === 'deagle' ? 0.01 : 0;
  dir.x += (Math.random()-0.5) * spread;
  dir.y += (Math.random()-0.5) * spread;
  dir.z += (Math.random()-0.5) * spread;
  dir.normalize();

  if(ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({
      type:'shoot',
      x: camera.position.x,
      y: camera.position.y,
      z: camera.position.z,
      dx: dir.x, dy: dir.y, dz: dir.z,
      weapon: currentWeapon
    }));
  }

  // Show tracer
  showTracer(camera.position.x, camera.position.y, camera.position.z, dir.x, dir.y, dir.z);

  // Bullet impact on walls
  const raycaster = new THREE.Raycaster(camera.position.clone(), dir, 0, 100);
  const meshes = mapBoxes.map(b => b.mesh);
  const hits = raycaster.intersectObjects(meshes);
  if(hits.length > 0) {
    showBulletHole(hits[0].point, hits[0].face.normal);
  }

  if(w.clip <= 0) {
    setTimeout(() => reload(), 300);
  }
}

function reload() {
  const w = weapons[currentWeapon];
  if(w.reloading || w.total <= 0 || w.clip === w.maxClip || currentWeapon === 'knife') return;
  w.reloading = true;
  document.getElementById('ammoClip').textContent = '...';

  // Reload animation
  if(gunMesh) {
    gunMesh.rotation.z = 0.3;
  }

  setTimeout(() => {
    const needed = w.maxClip - w.clip;
    const available = Math.min(needed, w.total);
    w.clip += available;
    w.total -= available;
    w.reloading = false;
    updateAmmoUI();
    if(gunMesh) gunMesh.rotation.z = 0;
  }, w.reloadTime);
}

function resetAmmo() {
  weapons.ak47.clip = 30; weapons.ak47.total = 90;
  weapons.deagle.clip = 7; weapons.deagle.total = 35;
  updateAmmoUI();
}

function updateAmmoUI() {
  const w = weapons[currentWeapon];
  document.getElementById('ammoClip').textContent = w.clip;
  document.getElementById('ammoTotal').textContent = w.total;
  document.getElementById('weaponName').textContent = w.name;
}

function updateHP() {
  const el = document.getElementById('hpNum');
  el.textContent = Math.max(0, hp);
  el.className = 'hp-num ' + (hp > 50 ? 'ok' : hp > 25 ? 'mid' : 'low');
}

// === VFX ===
function showMuzzleFlash() {
  const el = document.getElementById('muzzleFlash');
  el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), 50);
}

function showHitMarker() {
  const el = document.getElementById('hitMarker');
  el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), 200);
}

function showDamage() {
  const el = document.getElementById('dmgOverlay');
  el.classList.add('hit');
  setTimeout(() => el.classList.remove('hit'), 150);
}

function showTracer(x,y,z,dx,dy,dz) {
  const geo = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(x, y, z),
    new THREE.Vector3(x+dx*60, y+dy*60, z+dz*60)
  ]);
  const mat = new THREE.LineBasicMaterial({ color:0xffff66, transparent:true, opacity:0.4 });
  const line = new THREE.Line(geo, mat);
  scene.add(line);
  setTimeout(() => scene.remove(line), 80);
}

function showBulletHole(point, normal) {
  const geo = new THREE.CircleGeometry(0.05, 6);
  const mat = new THREE.MeshBasicMaterial({ color:0x111111, side:THREE.DoubleSide });
  const hole = new THREE.Mesh(geo, mat);
  hole.position.copy(point).add(new THREE.Vector3(normal.x*0.01, normal.y*0.01, normal.z*0.01));
  hole.lookAt(point.clone().add(normal));
  scene.add(hole);
  setTimeout(() => scene.remove(hole), 15000);
}

// === UI ===
function addKillFeed(killerId, victimId, weapon, headshot) {
  const feed = document.getElementById('killFeed');
  const entry = document.createElement('div');
  entry.className = 'kill-entry';
  const kName = players[killerId] ? players[killerId].name : 'Player';
  const vName = players[victimId] ? players[victimId].name : 'Player';
  entry.innerHTML = `<span class="killer">${kName}</span> [${weapon}${headshot?'★':''}] <span class="victim">${vName}</span>`;
  feed.appendChild(entry);
  setTimeout(() => entry.remove(), 4000);
  if(feed.children.length > 5) feed.firstChild.remove();
}

function addChat(name, msg) {
  const msgs = document.getElementById('chatMsgs');
  const el = document.createElement('div');
  el.className = 'chat-msg';
  el.innerHTML = `<span class="cn">${name}:</span> ${msg}`;
  msgs.appendChild(el);
  setTimeout(() => el.remove(), 10000);
  if(msgs.children.length > 8) msgs.firstChild.remove();
}

function updateRadar() {
  const canvas = document.getElementById('radarCanvas');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0,0,140,140);

  const scale = 1.2;
  const cx = 70, cy = 70;

  // Draw map walls on radar
  ctx.strokeStyle = 'rgba(0,100,0,0.3)';
  ctx.lineWidth = 1;
  for(const box of mapBoxes) {
    const rx = (box.min.x + box.max.x)/2 - camera.position.x;
    const rz = (box.min.z + box.max.z)/2 - camera.position.z;
    // Rotate by yaw
    const cos = Math.cos(yaw), sin = Math.sin(yaw);
    const sx = (rx * cos - rz * sin) * scale + cx;
    const sy = (rx * sin + rz * cos) * scale + cy;
    if(sx > 0 && sx < 140 && sy > 0 && sy < 140) {
      ctx.fillStyle = 'rgba(0,80,0,0.3)';
      ctx.fillRect(sx-1, sy-1, 2, 2);
    }
  }

  // Draw other players
  for(let pid in players) {
    if(pid == myId || !players[pid].alive) continue;
    const p = players[pid];
    const rx = p.x - camera.position.x;
    const rz = p.z - camera.position.z;
    const cos = Math.cos(yaw), sin = Math.sin(yaw);
    const sx = (rx * cos - rz * sin) * scale + cx;
    const sy = (rx * sin + rz * cos) * scale + cy;
    if(sx > 5 && sx < 135 && sy > 5 && sy < 135) {
      ctx.fillStyle = p.team === 'T' ? '#ff8800' : '#4488ff';
      ctx.beginPath();
      ctx.arc(sx, sy, 3, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // Direction indicator
  ctx.strokeStyle = '#0f0';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(cx, cy - 10);
  ctx.stroke();
}

function updateScoreboard() {
  const body = document.getElementById('sbBody');
  body.innerHTML = '';
  const sorted = Object.values(players).sort((a,b) => (b.kills||0) - (a.kills||0));
  for(const p of sorted) {
    const tr = document.createElement('tr');
    if(p.id == myId) tr.className = 'me';
    tr.innerHTML = `
      <td class="t-team ${p.team==='T'?'team-t':'team-ct'}">${p.team}</td>
      <td>${p.name||'Player'}</td>
      <td>${p.kills||0}</td>
      <td>${p.deaths||0}</td>
      <td>${p.alive?p.hp:'☠'}</td>
    `;
    body.appendChild(tr);
  }
}

// === INPUT ===
document.addEventListener('mousemove', (e) => {
  if(document.pointerLockElement && isAlive && !chatOpen) {
    const sens = parseFloat(document.getElementById('sensitivity').value) * 0.001 || 0.003;
    yaw += e.movementX * sens;
    pitch += e.movementY * sens;
    pitch = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, pitch));
    camera.rotation.order = 'YXZ';
    camera.rotation.y = -yaw;
    camera.rotation.x = -pitch;
  }
});

document.addEventListener('mousedown', (e) => {
  if(!document.pointerLockElement) {
    if(document.getElementById('menu').classList.contains('hidden')) {
      renderer.domElement.requestPointerLock();
    }
    return;
  }
  if(e.button === 0 && isAlive && !chatOpen) {
    shooting = true;
    tryShoot();
  }
});

document.addEventListener('mouseup', (e) => {
  if(e.button === 0) shooting = false;
});

document.addEventListener('keydown', (e) => {
  // Chat input handling
  if(chatOpen) {
    if(e.key === 'Enter') {
      const input = document.getElementById('chatInput');
      if(input.value.trim() && ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type:'chat', msg: input.value }));
        addChat(document.getElementById('playerName').value, input.value);
      }
      input.value = '';
      input.classList.remove('show');
      chatOpen = false;
      renderer.domElement.requestPointerLock();
    }
    if(e.key === 'Escape') {
      document.getElementById('chatInput').classList.remove('show');
      chatOpen = false;
      renderer.domElement.requestPointerLock();
    }
    return;
  }

  switch(e.code) {
    case 'KeyW': moveState.forward = 1; break;
    case 'KeyS': moveState.back = 1; break;
    case 'KeyA': moveState.left = 1; break;
    case 'KeyD': moveState.right = 1; break;
    case 'Space': e.preventDefault(); moveState.jump = true; break;
    case 'KeyR': reload(); break;
    case 'Digit1':
      currentWeapon = 'ak47'; updateAmmoUI();
      if(ws) ws.send(JSON.stringify({type:'switchWeapon',weapon:'ak47'}));
      break;
    case 'Digit2':
      currentWeapon = 'deagle'; updateAmmoUI();
      if(ws) ws.send(JSON.stringify({type:'switchWeapon',weapon:'deagle'}));
      break;
    case 'Digit3':
      currentWeapon = 'knife'; updateAmmoUI();
      if(ws) ws.send(JSON.stringify({type:'switchWeapon',weapon:'knife'}));
      break;
    case 'Tab':
      e.preventDefault();
      updateScoreboard();
      document.getElementById('scoreboard').classList.add('show');
      break;
    case 'KeyT':
    case 'KeyY':
      if(document.pointerLockElement) {
        document.exitPointerLock();
        chatOpen = true;
        const input = document.getElementById('chatInput');
        input.classList.add('show');
        input.focus();
      }
      break;
    case 'Escape':
      if(document.pointerLockElement) {
        document.exitPointerLock();
      }
      break;
  }
});

document.addEventListener('keyup', (e) => {
  if(chatOpen) return;
  switch(e.code) {
    case 'KeyW': moveState.forward = 0; break;
    case 'KeyS': moveState.back = 0; break;
    case 'KeyA': moveState.left = 0; break;
    case 'KeyD': moveState.right = 0; break;
    case 'Space': moveState.jump = false; break;
    case 'Tab':
      document.getElementById('scoreboard').classList.remove('show');
      break;
  }
});

// Prevent context menu
document.addEventListener('contextmenu', e => e.preventDefault());

// === MENU FUNCTIONS ===
function showSettings() {
  document.getElementById('settingsPanel').classList.add('show');
}
function hideSettings() {
  document.getElementById('settingsPanel').classList.remove('show');
}

function showControls() {
  alert(
    'MAXIS STRIKE - CONTROLS\n\n' +
    'WASD - Move\n' +
    'Mouse - Look\n' +
    'Left Click - Shoot\n' +
    'R - Reload\n' +
    'Space - Jump\n' +
    '1 - AK-47\n' +
    '2 - Desert Eagle\n' +
    '3 - Knife\n' +
    'T/Y - Chat\n' +
    'Tab - Scoreboard\n' +
    'Esc - Release mouse'
  );
}

function showAbout() {
  alert(
    'MAXIS STRIKE v1.0\n\n' +
    'A tactical multiplayer FPS\n' +
    'Built with Three.js & WebSocket\n\n' +
    'Start server: node server.js\n' +
    'Then click PLAY!'
  );
}
</script>
</body>
</html>
